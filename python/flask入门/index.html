


<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="梦想还是要有的">
      
      
        <link rel="canonical" href="https://www.baidu.com/python/flask%E5%85%A5%E9%97%A8/">
      
      
        <meta name="author" content="大熊">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.5.12">
    
    
      
        <title>flask入门 - 十二万光年</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.4dd2dd8d.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#flask" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="https://www.baidu.com" title="十二万光年" class="md-header-nav__button md-logo" aria-label="十二万光年">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            十二万光年
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              flask入门
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="https://www.baidu.com" title="十二万光年" class="md-nav__button md-logo" aria-label="十二万光年">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    十二万光年
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="首页" class="md-nav__link">
      首页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Git
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Git" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon"></span>
        Git
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../git/%E5%90%8C%E6%AD%A5mkdocs%E5%88%B0%E5%A4%9A%E4%B8%AAgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" title="同步mkdocs到多个git远程仓库" class="md-nav__link">
      同步mkdocs到多个git远程仓库
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Python
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Python" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        flask入门
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" title="flask入门" class="md-nav__link md-nav__link--active">
      flask入门
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#flask_1" class="md-nav__link">
    flask项目创建
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    开发环境搭建
  </a>
  
    <nav class="md-nav" aria-label="开发环境搭建">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    需要安装的包
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    创建虚拟环境
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_2" class="md-nav__link">
    安装flask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    开发环境
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flask_3" class="md-nav__link">
    最小Flask程序
  </a>
  
    <nav class="md-nav" aria-label="最小Flask程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    注册路由
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url" class="md-nav__link">
    URL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_1" class="md-nav__link">
    URL与端点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_4" class="md-nav__link">
    Flask命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模板与静态文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flaskhttp" class="md-nav__link">
    Flask与http
  </a>
  
    <nav class="md-nav" aria-label="Flask与http">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#url_2" class="md-nav__link">
    URL组成
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    请求类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#request" class="md-nav__link">
    request对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_5" class="md-nav__link">
    Flask处理请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http" class="md-nav__link">
    设置http监听方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_3" class="md-nav__link">
    URL处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    请求钩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http_1" class="md-nav__link">
    http响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_6" class="md-nav__link">
    在Flask中生成响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    重定向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    错误响应
  </a>
  
    <nav class="md-nav" aria-label="错误响应">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    响应格式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    纯文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#html" class="md-nav__link">
    HTML
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xml" class="md-nav__link">
    XML
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json" class="md-nav__link">
    JSON
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie" class="md-nav__link">
    Cookie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie_1" class="md-nav__link">
    安全的cookie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    模拟用户认证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_7" class="md-nav__link">
    Flask上下文变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http-referer" class="md-nav__link">
    HTTP referer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_4" class="md-nav__link">
    URL安全验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ajax" class="md-nav__link">
    AJAX异步请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jqueryajax" class="md-nav__link">
    使用jQuery发送AJAX请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    返回局部数据
  </a>
  
    <nav class="md-nav" aria-label="返回局部数据">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_1" class="md-nav__link">
    纯文本或局部HTML模板
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_1" class="md-nav__link">
    JSON数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    空值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    异步加载文章示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http_2" class="md-nav__link">
    http服务端推送
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#web" class="md-nav__link">
    web安全防范
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    防范措施
  </a>
  
    <nav class="md-nav" aria-label="防范措施">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_2" class="md-nav__link">
    html转义
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    模板
  </a>
  
    <nav class="md-nav" aria-label="模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jinja2" class="md-nav__link">
    Jinja2常见的定界符
  </a>
  
    <nav class="md-nav" aria-label="Jinja2常见的定界符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    注释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    模板语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    渲染模板
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    模板辅助工具
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    模板环境对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    模板结构组织
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    模板继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    子模板对父模板的操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#css" class="md-nav__link">
    CSS框架
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    使用宏加载静态资源
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java-scriptcssjinja2" class="md-nav__link">
    Java Script和CSS中的Jinja2
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    表单
  </a>
  
    <nav class="md-nav" aria-label="表单">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_3" class="md-nav__link">
    html表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask-wtf" class="md-nav__link">
    使用Flask-WTF处理表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wtforms" class="md-nav__link">
    定义WTForms表单类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#html_4" class="md-nav__link">
    输出html代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#render_kw" class="md-nav__link">
    使用render_kw属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    在调用字段时传入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    在模板中渲染表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    处理表单数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    提交表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    验证表单数据
  </a>
  
    <nav class="md-nav" aria-label="验证表单数据">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    客户端验证和服务端验证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wtforms_1" class="md-nav__link">
    WTForms验证机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    在视图函数中验证表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    在模板中渲染错误消息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    表单实践
  </a>
  
    <nav class="md-nav" aria-label="表单实践">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    设置错误消息语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    使用宏渲染表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    自定义验证器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    全局验证器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      系统
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="系统" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon"></span>
        系统
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%B3%BB%E7%BB%9F/windows2016%E7%94%B5%E8%AF%9D%E6%BF%80%E6%B4%BB/" title="WindowsServer电话激活操作步骤" class="md-nav__link">
      WindowsServer电话激活操作步骤
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%B3%BB%E7%BB%9F/%E5%85%B3%E4%BA%8ELinux%E7%9A%84skel%E7%9B%AE%E5%BD%95/" title="关于Linux的/etc/skel目录" class="md-nav__link">
      关于Linux的/etc/skel目录
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%B3%BB%E7%BB%9F/%E7%94%B1%E4%BA%8E%E6%B2%A1%E6%9C%89%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E8%AE%B8%E5%8F%AF%E8%AF%81%E8%BF%9C%E7%A8%8B%E4%BC%9A%E8%AF%9D%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="由于没有远程桌面授权服务器可以提供许可证远程会话被中断的解决方法" class="md-nav__link">
      由于没有远程桌面授权服务器可以提供许可证远程会话被中断的解决方法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      网络
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="网络" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon"></span>
        网络
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C/TCPIP%E5%8D%8F%E8%AE%AE/" title="TCP/IP协议" class="md-nav__link">
      TCP/IP协议
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C/Windows%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5VPN/" title="Windows实现自动连接VPN" class="md-nav__link">
      Windows实现自动连接VPN
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E7%BD%91%E7%BB%9C/%E4%B8%BAVmware-Workstation%E4%B8%AD%E7%9A%84Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AEV2ray%E4%BB%A3%E7%90%86/" title="为Vmware-Workstation中的Ubuntu虚拟机配置V2ray代理" class="md-nav__link">
      为Vmware-Workstation中的Ubuntu虚拟机配置V2ray代理
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      虚拟化
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="虚拟化" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        <span class="md-nav__icon md-icon"></span>
        虚拟化
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E8%99%9A%E6%8B%9F%E5%8C%96/Ubuntu18.04%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Devstack/" title="Ubuntu18.04安装部署Devstack" class="md-nav__link">
      Ubuntu18.04安装部署Devstack
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E8%99%9A%E6%8B%9F%E5%8C%96/%E4%BD%BF%E7%94%A8Hyper-V%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="使用Hyper-V创建虚拟机" class="md-nav__link">
      使用Hyper-V创建虚拟机
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../%E8%99%9A%E6%8B%9F%E5%8C%96/%E4%BD%BF%E7%94%A8%E7%94%A8vnc%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E4%BE%8B/" title="使用用vnc客户端连接虚拟机实例" class="md-nav__link">
      使用用vnc客户端连接虚拟机实例
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#flask_1" class="md-nav__link">
    flask项目创建
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    开发环境搭建
  </a>
  
    <nav class="md-nav" aria-label="开发环境搭建">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    需要安装的包
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    创建虚拟环境
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_2" class="md-nav__link">
    安装flask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    开发环境
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flask_3" class="md-nav__link">
    最小Flask程序
  </a>
  
    <nav class="md-nav" aria-label="最小Flask程序">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    注册路由
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url" class="md-nav__link">
    URL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_1" class="md-nav__link">
    URL与端点
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_4" class="md-nav__link">
    Flask命令
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模板与静态文件
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flaskhttp" class="md-nav__link">
    Flask与http
  </a>
  
    <nav class="md-nav" aria-label="Flask与http">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#url_2" class="md-nav__link">
    URL组成
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    请求类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#request" class="md-nav__link">
    request对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_5" class="md-nav__link">
    Flask处理请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http" class="md-nav__link">
    设置http监听方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_3" class="md-nav__link">
    URL处理
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    请求钩子
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http_1" class="md-nav__link">
    http响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_6" class="md-nav__link">
    在Flask中生成响应
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    重定向
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    错误响应
  </a>
  
    <nav class="md-nav" aria-label="错误响应">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    响应格式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    纯文本
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#html" class="md-nav__link">
    HTML
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xml" class="md-nav__link">
    XML
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json" class="md-nav__link">
    JSON
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie" class="md-nav__link">
    Cookie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cookie_1" class="md-nav__link">
    安全的cookie
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    模拟用户认证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask_7" class="md-nav__link">
    Flask上下文变量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http-referer" class="md-nav__link">
    HTTP referer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#url_4" class="md-nav__link">
    URL安全验证
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ajax" class="md-nav__link">
    AJAX异步请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jqueryajax" class="md-nav__link">
    使用jQuery发送AJAX请求
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    返回局部数据
  </a>
  
    <nav class="md-nav" aria-label="返回局部数据">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_1" class="md-nav__link">
    纯文本或局部HTML模板
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#json_1" class="md-nav__link">
    JSON数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    空值
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    异步加载文章示例
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#http_2" class="md-nav__link">
    http服务端推送
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#web" class="md-nav__link">
    web安全防范
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    防范措施
  </a>
  
    <nav class="md-nav" aria-label="防范措施">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_2" class="md-nav__link">
    html转义
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    模板
  </a>
  
    <nav class="md-nav" aria-label="模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jinja2" class="md-nav__link">
    Jinja2常见的定界符
  </a>
  
    <nav class="md-nav" aria-label="Jinja2常见的定界符">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    注释
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    模板语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    渲染模板
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    模板辅助工具
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    模板环境对象
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    模板结构组织
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    模板继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    子模板对父模板的操作
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#css" class="md-nav__link">
    CSS框架
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    使用宏加载静态资源
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#java-scriptcssjinja2" class="md-nav__link">
    Java Script和CSS中的Jinja2
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    表单
  </a>
  
    <nav class="md-nav" aria-label="表单">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#html_3" class="md-nav__link">
    html表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flask-wtf" class="md-nav__link">
    使用Flask-WTF处理表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wtforms" class="md-nav__link">
    定义WTForms表单类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#html_4" class="md-nav__link">
    输出html代码
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#render_kw" class="md-nav__link">
    使用render_kw属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    在调用字段时传入
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    在模板中渲染表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    处理表单数据
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    提交表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    验证表单数据
  </a>
  
    <nav class="md-nav" aria-label="验证表单数据">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    客户端验证和服务端验证
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wtforms_1" class="md-nav__link">
    WTForms验证机制
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    在视图函数中验证表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    在模板中渲染错误消息
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    表单实践
  </a>
  
    <nav class="md-nav" aria-label="表单实践">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    设置错误消息语言
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    使用宏渲染表单
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    自定义验证器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    全局验证器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h1 id="flask">flask入门<a class="headerlink" href="#flask" title="Permanent link">&para;</a></h1>
<h2 id="flask_1">flask项目创建<a class="headerlink" href="#flask_1" title="Permanent link">&para;</a></h2>
<p>克隆github上flask项目文件到本地：</p>
<p><code>git clone https://github.com/greyli/helloflask.git</code>
<code>cd helloflask</code></p>
<p>也可以在github点击该项目fork后，再复制自己项目地址：</p>
<p><code>git clone https://github.com/chyuhung/helloflask.git</code></p>
<h2 id="_1">开发环境搭建<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="_2">需要安装的包<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>1、安装python，使用3.6及以上版本；</p>
<p>2、安装python包管理工具pip，可以使用<code>pip --version</code>命令查看已经安装的版本，安装后如需安装需要的其他包，可以使用命令<code>pip install [包名]</code>方便快速的进行安装；</p>
<p>3、安装pipenv，它是基于pip的python包管理工具，用法与pip相似，可以看作pip加强版，它解决了pip+virtualenv+requirements.txt的工作方式弊端，可以说它是pip、Pipfile、Virtualenv的结合体，安装完pip以后，使用命令<code>pip install pipenv</code>进行安装，使用命令<code>pipenv --version</code>查看安装的版本。</p>
<h3 id="_3">创建虚拟环境<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>1、进入项目目录，使用命令<code>pipenv install</code>即可为当前项目创建虚拟环境，它会创建“项目目录名+随机字符”的文件夹，并且安装pip，wheel、setuptools等基本的包，flask示例项目中包含Pipfile文件，文件中列出的包也会一并安装；</p>
<p>2、安装完成后，使用命令<code>pipenv shell</code>激活虚拟环境，使用<code>pipenv run</code>命令，如：<code>pipenv run python hello.py</code>则不需要关心是否激活了虚拟环境；</p>
<p>3、依赖管理：一个程序通常会使用很多的Python包，即依赖(dependency)。而程序不仅仅会在一台电脑上运行，程序部署上线时需要安装到远程服务器上，为了能顺利运行程序，不得不记下所有依赖包，然后使用pip或Pipenv安装，这些重复无用的工作当然应该避免。在以前通常使用pip搭配一个requirements.txt文件来记录依赖。但requirements.txt需要手动维护，在使用上不够灵活。Pipfile的出现就是为了替代难于管理的requirements.txt。在创建虚拟环境时，如果项目根目录下没有Pipfile文件，pipenv install命令还会在项目文件夹根目录下创建Pipfile和Pipfile.lock文件，前者用来记录项目依赖包列表，而后者记录了固定版本的详细依赖包列表。当使用Pipenv安装/删除/更新依赖包时，Pipfile以及Pipfile.lock会自动更新。</p>
<h3 id="flask_2">安装flask<a class="headerlink" href="#flask_2" title="Permanent link">&para;</a></h3>
<p>使用命令<code>pipenv install flask</code>在项目文件夹下安装flask，pipenv能够自动管理虚拟环境，使用pipenv命令安装的包都在虚拟环境中，而需要在全局环境下安装包等才使用pip命令。</p>
<p>安装Flask会默认同时安装Flask依赖包。</p>
<p><img alt="image-20201218155935922" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201218155935922.png" /></p>
<h3 id="_4">开发环境<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>使用Pycharm打开项目文件夹能够自动识别虚拟环境，再进行简单的配置即可。</p>
<p><img alt="image-20201218160202606" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201218160202606.png" /></p>
<h2 id="flask_3">最小Flask程序<a class="headerlink" href="#flask_3" title="Permanent link">&para;</a></h2>
<p>项目程序目录，示例代码为hello小程序。</p>
<p><img alt="image-20201218161047653" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201218161047653.png" /></p>
<p>app.py代码，一般简单程序命令使用app.py，也可以自定义，避免使用flask.py，会与Flask本身冲突。</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;h1&gt;Hello Flask!&lt;/h1&gt;&#39;</span>
</code></pre></div>

<p>传入Flask构造方法的第一个参数是模块或包名称，使用特殊变量<code>__name__</code>，python能够根据所处模块自动赋值到<code>__name__</code>，对app.py这个程序来说，值为app。</p>
<h3 id="_5">注册路由<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>在这个程序里，app.route()装饰器把根地址/和index()函数绑定起来，当用户访问这个URL时就会触发index()函数。</p>
<p>在一个Web应用里，客户端和服务器上的Flask程序的交互可以简单概括为以下几步：
1）用户在浏览器输入URL访问某个资源。
2）Flask接收用户请求并分析请求的URL。
3）为这个URL找到对应的处理函数。
4）执行函数并生成响应，返回给浏览器。
5）浏览器接收并解析响应，将信息显示在页面中。</p>
<h3 id="url">URL<a class="headerlink" href="#url" title="Permanent link">&para;</a></h3>
<p>绑定多个URL到视图：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@app</span><span class="o">.</span> <span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hi&#39;</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
<span class="k">return</span> <span class="s1">&#39;&lt;h1&gt;Hello，Flask !&lt;/h1&gt;&#39;</span>
</code></pre></div>

<p>动态URL</p>
<p>即在URL中添加变量，使用“&lt;变量名&gt;”的形式表示，Flask处理请求时会把变量传入视图函数。</p>
<div class="highlight"><pre><span></span><code>#test
@app.route(&#39;/hi/&lt;new_name&gt;&#39;)
def hi_new_name(new_name):
    response=&#39;&lt;h1&gt;hi,%s&lt;/h1&gt;&#39;%new_name
    return  response
</code></pre></div>

<p>URL中包含变量，则将传入视图函数的字符串称为URL规则，Flask将请求URL和URL规则匹配，如示例代码，/hi/peter，/hi/bob等请求都能够触发这个视图函数。</p>
<p><img alt="image-20201219175818098" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219175818098.png" /></p>
<p><img alt="image-20201219180219958" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219180219958.png" /></p>
<p>当URL中包含变量，如果用户访问的URL中没有变量，如/hi，Flask在匹配失败后会返回404错误。</p>
<p><img alt="image-20201219180449961" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219180449961.png" /></p>
<p>常见的做法时在app.route()装饰器中使用deefaults参数设置URL变量的默认值，该参数接收字典作为输入，存储URL变量和默认值的映射。</p>
<div class="highlight"><pre><span></span><code>#test
@app.route(&#39;/hi/&#39;,defaults={&#39;new_name&#39;:&#39;chyuhung&#39;})
def hi_new_name(new_name):
    response=&#39;&lt;h1&gt;hi,%s&lt;/h1&gt;&#39;%new_name
    return  response
</code></pre></div>

<p>设置默认值new_name为“chyuhung”。</p>
<p><img alt="image-20201219181259517" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219181259517.png" /></p>
<h3 id="url_1">URL与端点<a class="headerlink" href="#url_1" title="Permanent link">&para;</a></h3>
<p>Web程序中，URL无处不在，如果程序中URL都以硬编码方式写出，将会大大降低代码易用性。当修改了某个URL规则，程序对应的URL都要一个个进行修改，更好的方法时使用Flask提供的usr_for()函数获取URL，当路由定义中的URL规则被修改时，这个函数能够返回正确的URL。</p>
<div class="highlight"><pre><span></span><code>#test01
@app.route(&#39;/test01&#39;)
def test01():
    url=url_for(&#39;test01&#39;)
    response = &quot;hello,test01!url is %s&quot;%url
    return response
</code></pre></div>

<p>这个路由的端点即视图函数的名称test01，调用url_for('test01')即可获取对应的URL，即“/test01”。</p>
<p><img alt="image-20201219182451307" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219182451307.png" /></p>
<p>如果URL含有动态部分，在url_for()函数里也需要传入相应的参数。</p>
<div class="highlight"><pre><span></span><code>#test01
@app.route(&#39;/test01/&lt;test_num&gt;&#39;)
def test01(test_num):
    url=url_for(&#39;test01&#39;,test_num=&#39;01&#39;)
    response = &quot;hello,test01!url is %s&quot;%url
    return response
</code></pre></div>

<p><img alt="image-20201219182911489" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219182911489.png" /></p>
<p>使用url_for()函数生成的URL是相对URL(即内部URL)，即URL中的path部分，比如“/hello”，不包含根URL。相对URL只能在程序内部使用。如果想要生成供外部使用的绝对URL，可以在使用url_for()函数时，将_external参数设为True，这会生成完整的URL。</p>
<h3 id="flask_4">Flask命令<a class="headerlink" href="#flask_4" title="Permanent link">&para;</a></h3>
<p>通过创建任意一个函数，并为其添加app.cli.command()装饰器，就可以注册一个flask命令。</p>
<div class="highlight"><pre><span></span><code>#自定义命令
@app.cli.command()
def test():
    click.echo(&#39;this is a test&#39;)
</code></pre></div>

<p><img alt="image-20201219183619753" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219183619753.png" /></p>
<p>函数的名称即为命令名称，这里注册的命令即test，使用flask test命令来触发函数。作为替代，可以在app.cli.command()装饰器中传入参数来设置命令名称，比如app.cli.command('hello')会把命令名称设置为hello，完整的命令即flask hello。</p>
<div class="highlight"><pre><span></span><code>#自定义命令
@app.cli.command(&#39;hello&#39;)
def test():
    click.echo(&#39;this is a test&#39;)
</code></pre></div>

<p><img alt="image-20201219183829360" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201219183829360.png" /></p>
<p>此外，借助click模块的echo()函数，可以在命令行界面输出字符。</p>
<h3 id="_6">模板与静态文件<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>一个完整的网站当然不能只返回用户一句“Hello,World!”，需要模板(template)和静态文件(static file）来生成更加丰富的网页。模板即包含程序页面的HTML文件，静态文件则是需要在HTML文件中加载的CSS和Java Script文件，以及图片、字体文件等资源文件。默认情况下，模板文件存放在项目根目录中的templates文件夹中，静态文件存放在static文件夹下，这两个文件夹需要和包含程序实例的模块处于同一个目录下，对应的项目结构示例如下所示：</p>
<div class="highlight"><pre><span></span><code>hello/
- templates/
- static/
- app.py
</code></pre></div>

<h2 id="flaskhttp">Flask与http<a class="headerlink" href="#flaskhttp" title="Permanent link">&para;</a></h2>
<p><img alt="image-20201221120651734" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221120651734.png" /></p>
<p><img alt="image-20201221120711310" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221120711310.png" /></p>
<p>当用户访问一个URL，浏览器便生成对应的HTTP请求，经由互联网发送到对应的Web服务器。Web服务器接收请求，通过WSGI将HTTP格式的请求数据转换成Flask程序能够使用的Python数据。在程序中，Flask根据请求的URL执行对应的视图函数，获取返回值生成响应。响应依次经过wSGI转换生成HTTP响应，再经由Web服务器传递，最终被发出请求的客户端接收。浏览器渲染响应中包含的HTML和CSS代码，并执行Java Script代码，最终把解析后的页面呈现在用户浏览器的窗口中。</p>
<h3 id="url_2">URL组成<a class="headerlink" href="#url_2" title="Permanent link">&para;</a></h3>
<p>示例URL</p>
<div class="highlight"><pre><span></span><code>http://helloflask.com/hello?name=Grey
</code></pre></div>

<p><img alt="image-20201221120853513" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221120853513.png" /></p>
<p>这个URL后面的?name=Grey部分是查询字符串( querystring)。URL中的查询字符串用来向指定的资源传递参数。查询字符串从问号?开始，以键值对的形式写出，多个键值对之间使用&amp;分隔。</p>
<p>浏览器与服务器之间交互的数据被称为报文( message)，请求时浏览器发送的数据被称为请求报文( request message)，而服务器返回的数据被称为响应报文(response message) 。</p>
<h3 id="_7">请求类型<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>HTTP通过方法来区分不同的请求类型。当直接访问一个页面时，请求的方法是GET;当在某个页面填写了表单并提交时，请求方法则通常为POST。</p>
<p><img alt="image-20201221121129097" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221121129097.png" /></p>
<h3 id="request">request对象<a class="headerlink" href="#request" title="Permanent link">&para;</a></h3>
<p>Flask的请求对象request，这个请求对象封装了从客户端发来的请求报文，能从它获取请求报文中的所有数据。请求解析和响应封装实际上大部分是由Werkzeug完成的，Flask子类化Werkzeug的请求（Request)和响应(Response)对象并添加了和程序相关的特定功能。</p>
<p>示例URL</p>
<div class="highlight"><pre><span></span><code>http://helloflask.com/hello?name=Grey
</code></pre></div>

<p>使用request对象属性获取请求URL<img alt="image-20201221121428976" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221121428976.png" /></p>
<p>request对象常用的属性和方法</p>
<p><img alt="image-20201221130310056" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221130310056.png" /></p>
<h3 id="flask_5">Flask处理请求<a class="headerlink" href="#flask_5" title="Permanent link">&para;</a></h3>
<p>当请求的URL与某个视图函数的URL规则匹配成功时，对应的视图函数就会被调用。使用flask routes命令可以查看程序中定义的所有路由，这个列表由app.url_map解析得到。</p>
<p><img alt="image-20201221131008727" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221131008727.png" /></p>
<h3 id="http">设置http监听方法<a class="headerlink" href="#http" title="Permanent link">&para;</a></h3>
<p>可以在app.route()装饰器中使用methods参数传入一个包含监听的HTTP方法的可迭代对象。比如，下面的视图函数同时监听GET请求和POST请求:</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/hi&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def hi():
    return redirect(url_for(&#39;hello&#39;))
</code></pre></div>

<h3 id="url_3">URL处理<a class="headerlink" href="#url_3" title="Permanent link">&para;</a></h3>
<p>URL规则中的变量部分有一些特别, <int:year>表示为year变量添加了一个int转换器，Flask在解析这个URL变量时会将其转换为整型。URL中的变量部分默认类型为字符串，但Flask提供了一些转换器可以在URL规则里使用。</p>
<p><img alt="image-20201221131614013" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221131614013.png" /></p>
<div class="highlight"><pre><span></span><code><span class="c1">#use int URL converter</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/goto/&lt;int:year&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">goto</span><span class="p">(</span><span class="n">year</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;welcome to </span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="mi">2020</span><span class="o">+</span><span class="n">year</span><span class="p">)</span>
</code></pre></div>

<p><img alt="image-20201221131845292" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221131845292.png" /></p>
<p>在用法上唯一特别的是any转换器，需要在转换器后添加括号来给出可选值，即"<any(value1, value2，...):变量名>"。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/colors/&lt;any(blue, white, red):color&gt;&#39;)
</code></pre></div>

<p>如果想要在any转换器中传入一个预先定义的列表，可以通过格式化字符串的方式（使用%或是format函数）来构建URL规则字符串。</p>
<div class="highlight"><pre><span></span><code><span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span><span class="s1">&#39;white&#39;</span><span class="p">,</span><span class="s1">&#39;dark&#39;</span><span class="p">,</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="s1">&#39;green&#39;</span><span class="p">,</span><span class="s1">&#39;yellow&#39;</span><span class="p">]</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/colors/&lt;any(</span><span class="si">%s</span><span class="s1">):color&gt;&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">colors</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div>

<h3 id="_8">请求钩子<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>有时需要对请求进行预处理( preprocessing)和后处理( postprocessing)，这时可以使用Flask提供的一些请求钩子(Hook)，它们可以用来注册在请求处理的不同阶段执行的处理函数(或称为回调函数，即Callback)。这些请求钩子使用装饰器实现，通过程序实例app调用，用法很简单:以before_request钩子(请求之前)为例，当对一个函数附加了app.before_request装饰器后，就会将这个函数注册为before_request处理函数，每次执行请求前都会触发所有before_request处理函数。</p>
<p><img alt="image-20201221133519896" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221133519896.png" /></p>
<p>示例代码</p>
<div class="highlight"><pre><span></span><code>@app.before_request
def do_something():
    return &#39;your request got!&#39;
</code></pre></div>

<p><img alt="image-20201221133827965" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221133827965.png" /></p>
<p>处理流程示意图</p>
<p><img alt="image-20201221133921221" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221133921221.png" /></p>
<p>请求钩子常见应用场景：</p>
<p>before_first_request:在玩具程序中，运行程序前需要进行一些程序的初始化操作，比如创建数据库表，添加管理员用户。这些工作可以放到使用before_first_request装饰器注册的函数中。
before_request:比如网站上要记录用户最后在线的时间，可以通过用户最后发送的请求时间来实现。为了避免在每个视图函数都添加更新在线时间的代码，可以仅在使用before_request钩子注册的函数中调用这段代码。
after_request:经常在视图函数中进行数据库操作，比如更新、插入等，之后需要将更改提交到数据库中。提交更改的代码就可以放到after_request钩子注册的函数中。</p>
<p>另一种常见的应用是建立数据库连接，通常会有多个视图函数需要建立和关闭数据库连接，这些操作基本相同。一个理想的解决方法是在请求之前( before_request)建立连接，在请求之后(teardown_request)关闭连接。通过在使用相应的请求钩子注册的函数中添加代码就可以实现。这很像单元测试中的set Up()方法和tear Down()方法。</p>
<p>重要：after_request钩子和after_this_request钩子必须接收一个响应类对象作为参数，并且返回同一个或更新后的响应对象。</p>
<h3 id="http_1">http响应<a class="headerlink" href="#http_1" title="Permanent link">&para;</a></h3>
<p>响应报文主要由协议版本、状态码( status code)、原因短语( reason phrase) 、响应首部和响应主体组成。</p>
<p><img alt="image-20201221135817689" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221135817689.png" /></p>
<p>http状态码用来表示请求处理的结果</p>
<p><img alt="image-20201221135858263" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221135858263.png" /></p>
<p>当关闭调试模式时，即FLASK_ENV使用默认值production，如果程序出错，Flask会自动返回500错误响应;而调试模式下则会显示调试信息和错误堆栈。</p>
<h3 id="flask_6">在Flask中生成响应<a class="headerlink" href="#flask_6" title="Permanent link">&para;</a></h3>
<p>响应在Flask中使用response对象表示，响应报文中的大部分内容由服务器处理。Flask会先判断是否可以找到与请求URL相匹配的路由，如果没有则返回404响应。如果找到，则调用对应的视图函数，视图函数的返回值构成了响应报文的主体内容，正确返回时状态码默认为200。Flask会调用make_response()方法将视图函数返回值转换为响应对象。</p>
<p>完整地说，视图函数可以返回最多由三个元素组成的元组:响应主体、状态码、首部字段。其中首部字段可以为字典，或是两元素元组组成的列表。</p>
<p><img alt="image-20201221144648754" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221144648754.png" /></p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/hi&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def hi():
    return &#39;&#39;,205
</code></pre></div>

<p><img alt="image-20201221145541620" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221145541620.png" /></p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/hi&#39;)
def hi():
    return &#39;&#39;,302,&#39;http://www.example.com&#39;
</code></pre></div>

<p><img alt="image-20201221154403114" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221154403114.png" /></p>
<h3 id="_9">重定向<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p><img alt="image-20201221145954677" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221145954677.png" /></p>
<p>对于重定向这一类特殊响应，Flask提供了一些辅助函数。除了手动生成302响应，可以使用Flask提供的redirect()函数来生成重定向响应，重定向的目标URL作为第一个参数。</p>
<p>在Web程序中，经常需要进行重定向。比如，当某个用户在没有经过认证的情况下访问需要登录后才能访问的资源，程序通常会重定向到登录页面。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/hi&#39;)
def hi():
    return redirect(&#39;http://www.example.com&#39;)
</code></pre></div>

<p><img alt="image-20201221154235592" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221154235592.png" /></p>
<p>使用redirect()函数时，默认的状态码为302，即临时重定向。如果想修改状态码，可以在redirect()函数中作为第二个参数或使用code关键字传入。</p>
<p>如果要在程序内重定向到其他视图，那么只需在redirect()函数中使用url_for()函数生成目标URL即可。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/hi&#39;)
def hi():
    return redirect(url_for(&#39;hello&#39;))#重定向到“hello”
</code></pre></div>

<h3 id="_10">错误响应<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>大多数情况下，Flask会自动处理常见的错误响应。HTTP错误对应的异常类在Werkzeug的werkzeug.exceptions模块中定义，抛出这些异常即可返回对应的错误响应。如果想手动返回错误响应，更方便的方法是使用Flask提供的abort()函数。</p>
<p>在abort()函数中传入状态码即可返回对应的错误响应。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/404&#39;)
def not_found():
    abort(404)
</code></pre></div>

<p>abort()函数前不需要使用return语句，但一旦abort()函数被调用，abort()函数之后的代码将不会被执行。</p>
<h4 id="_11">响应格式<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>通常使用HTML格式，不同格式需要不同的MIME类型，在首部Content-Type字段中定义。</p>
<p><img alt="image-20201221155906464" src="../flask%E5%85%A5%E9%97%A8.assets/image-20201221155906464.png" /></p>
<p>MIME类型(又称为media type或content type）是一种用来标识文件类型的机制，它与文件扩展名相对应，可以让客户端区分不同的内容类型，并执行不同的操作。一般的格式为“类型名/子类型名”，其中的子类型名一般为文件扩展名。比如，HTML的MIME类型为“text/html” , png图片的MIME类型为“image/png”。</p>
<p>如果想使用其他MIME类型，可以通过Flask提供的make_response()方法生成响应对象，传入响应的主体作为参数，然后使用响应对象的mimetype属性设置MIME类型。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/test&#39;)
def test():
    response=make_response(&#39;this is a test&#39;)
    response.mimetype=&#39;text/plain&#39;
    return response
</code></pre></div>

<p>常用的数据格式有纯文本、HTML、XML和JSON。</p>
<h4 id="_12">纯文本<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>MIME类型:text/plain</p>
<p>事实上，其他几种格式本质上都是纯文本。比如同样是一行包含HTML标签的文本“<h1>Hello，Flask!</h1>”，当MIME类型设置为纯文本时，浏览器会以文本形式显示“<h1>Hello,Flask!</h1>” ;当MIME类型声明为text/html时，浏览器则会将其作为标题1样式的HTML代码渲染。</p>
<div class="highlight"><pre><span></span><code>Note
to: Peter
from: Jane
heading: Reminder
body: Don&#39;t forget the party!
</code></pre></div>

<h4 id="html">HTML<a class="headerlink" href="#html" title="Permanent link">&para;</a></h4>
<p>MIME类型:text/html</p>
<p>HTML ( <a href="https://www.w3.org/html/)指Hypertext">https://www.w3.org/html/)指Hypertext</a> MarkupLanguage(超文本标记语言)，是最常用的数据格式，也是Flask返回响应的默认数据类型。</p>
<div class="highlight"><pre><span></span><code><span class="cp">&lt;! DOCTYPE html&gt;</span>
        <span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Note<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>to: Peter<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>from: Jane<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>heading: Reminder<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>body: <span class="p">&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>Don&#39;t forget the party! <span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>

<p>因为HTML常常包含丰富的信息，可以直接将HTML嵌入页面中，处理起来比较方便。因此，在普通的HTTP请求中使用HTTP作为响应的内容，这也是默认的数据类型。</p>
<h4 id="xml">XML<a class="headerlink" href="#xml" title="Permanent link">&para;</a></h4>
<p>MIME类型: application/xml</p>
<p>XML (<a href="https://www.w3.org/XML/)指Extensible">https://www.w3.org/XML/)指Extensible</a> MarkupLanguage(可扩展标记语言)，它是一种简单灵活的文本格式，被设计用来存储和交换数据。XML的出现主要就是为了弥补HTML的不足:对于仅仅需要数据的请求来说，HTML提供的信息太过丰富了，而且不易于重用。XML和HTML一样都是标记性语言，使用标签来定义文本，但HTML中的标签用于显示内容，而XML中的标签只用于定义数据。XML一般作为AJAX请求的响应格式，或是WebAPI的响应格式。</p>
<div class="highlight"><pre><span></span><code><span class="err">&lt;</span>? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;? &gt;
        <span class="nt">&lt;note&gt;</span>
            <span class="nt">&lt;to&gt;</span>Peter<span class="nt">&lt;/to&gt;</span>
            <span class="nt">&lt;from&gt;</span>Jane<span class="nt">&lt;/from&gt;</span>
            <span class="nt">&lt;heading&gt;</span>Reminder<span class="nt">&lt;/heading&gt;</span>
            <span class="nt">&lt;body&gt;</span>Don&#39;t forget the party! <span class="nt">&lt;/body&gt;</span>
        <span class="nt">&lt;/note&gt;</span>
</code></pre></div>

<h4 id="json">JSON<a class="headerlink" href="#json" title="Permanent link">&para;</a></h4>
<p>MIME类型: application/json</p>
<p>JSON ( <a href="http://json.org/)指Java">http://json.org/)指Java</a> Script Object Notation ( JavaScript对象表示法)，是一种流行的、轻量的数据交换格式。它的出现又弥补了XML的诸多不足:XML有较高的重用性，但XML相对于其他文档格式来说体积稍大，处理和解析的速度较慢。JSON轻量，简洁，容易阅读和解析，而且能和Web默认的客户端语言JavaScript更好地兼容。JSON的结构基于“键值对的集合”和“有序的值列表”，这两种数据结构类似Python中的字典(dictionary)和列表( list)。正是因为这种通用的数据结构，使得JSON在同样基于这些结构的编程语言之间交换成为可能。</p>
<div class="highlight"><pre><span></span><code>    <span class="p">{</span>
            <span class="nt">&quot;note&quot;</span><span class="p">:{</span>
                <span class="nt">&quot;to&quot;</span><span class="p">:</span><span class="s2">&quot;Peter&quot;</span><span class="p">,</span>
                <span class="nt">&quot;from&quot;</span><span class="p">:</span><span class="s2">&quot;Jane&quot;</span><span class="p">,</span>
                <span class="nt">&quot;heading&quot;</span><span class="p">:</span><span class="s2">&quot;Remider&quot;</span><span class="p">,</span>
                <span class="nt">&quot;body&quot;</span><span class="p">:</span><span class="s2">&quot;Don&#39;t forget the party! &quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>

<p>Flask通过引入Python标准库中的json模块（或simplejson，如果可用)为程序提供了JSON支持。可以直接从Flask中导入json对象，然后调用dumps()方法将字典、列表或元组序列化(serialize)为JSON字符串，再使用前面介绍的方法修改MIME类型，即可返回JSON响应。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/test01&#39;)
def test01():
    data={
        &#39;name&#39;:&#39;chyuhung&#39;,
        &#39;number&#39;:&#39;77777&#39;
    }
    response=make_response(json.dumps(data))
    response.mimetype=&#39;application/json&#39;
    return response
</code></pre></div>

<p><img alt="image-20210106154343595" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106154343595.png" /></p>
<p>一般并不直接使用json模块的dumps()、load()等方法，因为Flask通过包装这些方法提供了更方便的jsonify()函数。</p>
<div class="highlight"><pre><span></span><code>from flask import jsonify
@app.route(&#39;/test02&#39;)
def test02():
    return jsonify(name=&#39;chyuhung&#39;,num=&#39;7&#39;)
</code></pre></div>

<p><img alt="image-20210106154639602" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106154639602.png" /></p>
<h3 id="cookie">Cookie<a class="headerlink" href="#cookie" title="Permanent link">&para;</a></h3>
<p>HTTP是无状态(stateless)协议。也就是说，在一次请求响应结束后，服务器不会留下任何关于对方状态的信息。但是对于某些Web程序来说，客户端的信息必须被记住，比如登录状态，这样才可以根据用户的状态来返回不同的响应。为了解决这类问题，就有了Cookie技术。Cookie技术通过在请求和响应报文中添加Cookie数据来保存客户端的状态信息。</p>
<p>Cookie指Web服务器为了存储某些数据（比如用户信息）而保存在浏览器上的小型文本数据。浏览器会在一定时间内保存它，并在下一次向同一个服务器发送请求时附带这些数据。Cookie通常被用来进行用户会话管理(比如登录状态)，保存用户的个性化信息（比如语言偏好，视频上次播放的位置，网站主题选项等）以及记录和收集用户浏览数据以用来分析用户行为等。</p>
<p>在Flask中，如果想要在响应中添加一个cookie，最方便的方法是使用Response类提供的set_cookie()方法。要使用这个方法，需要先使用make_response()方法手动生成一个响应对象，传入响应主体作为参数。这个响应对象默认实例化内置的Response类。</p>
<p><img alt="image-20210106155244308" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106155244308.png" /></p>
<p>除上表中的属性和方法以外，Response类拥有和request类相同的get_json()方法、is_json()方法和json属性。</p>
<p>set_cookie()方法支持多个参数设置cookie选项。</p>
<p><img alt="image-20210106155517366" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106155517366.png" /></p>
<div class="highlight"><pre><span></span><code>from flask import Flask,make_response
@app.route(&#39;/test03/&lt;name&gt;&#39;)
def test03(name):
    response=make_response(redirect(url_for(&#39;hello&#39;)))
    response.set_cookie(&#39;name&#39;,name)
    return response
</code></pre></div>

<p>浏览器输入URL，重定向到hello程序</p>
<p><img alt="image-20210106174713954" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106174713954.png" /></p>
<p><img alt="image-20210106174743101" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106174743101.png" /></p>
<p>查看浏览器cookie</p>
<p><img alt="image-20210106174930821" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106174930821.png" /></p>
<p>当浏览器保存了服务器端设置的Cookie后，浏览器再次发送到该服务器的请求会自动携带设置的Cookie信息，Cookie的内容存储在请求首部的Cookie字段中。</p>
<p><img alt="image-20210106175124776" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210106175124776.png" /></p>
<h3 id="cookie_1">安全的cookie<a class="headerlink" href="#cookie_1" title="Permanent link">&para;</a></h3>
<p>在编程中，session指用户会话(user session) ，又称为对话(dialogue)，即服务器和客户端/浏览器之间或桌面程序和用户之间建立的交互活动。在Flask中, session对象用来加密Cookie。默认情况下，它会把数据存储在浏览器上一个名为session的cookie里。</p>
<p>session通过密钥对数据进行签名以加密数据，因此，得先设置一个密钥。这里的密钥就是一个具有一定复杂度和随机性的字符串，比如“Drmhze6EPcvOf N_81Bj-n A”。
程序的密钥可以通过Flask.secret_key属性或配置变量SECRET_KEY设置。</p>
<div class="highlight"><pre><span></span><code>app.secret_key = &#39;secret string&#39;
</code></pre></div>

<p>更安全的做法是把密钥写进系统环境变量（在命令行中使用export或set命令)，或是保存在.env文件中。</p>
<div class="highlight"><pre><span></span><code>SECRET_KEY=secret string
</code></pre></div>

<h3 id="_13">模拟用户认证<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>from flask import redirect,session,url_for
@app.route(&#39;/logintest&#39;)
def logintest():
    session[&#39;logged_in&#39;]=True
    return redirect(url_for(&#39;hello&#39;))
</code></pre></div>

<p><img alt="image-20210107094046091" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107094046091.png" /></p>
<p>这个登录视图只是简化的示例，在实际的登录中，需要在页面上提供登录表单，供用户填写账户和密码，然后在登录视图里验证账户和密码的有效性。session对象可以像字典一样操作，向session中添加一个logged-in cookie，将它的值设为True，表示用户已认证。</p>
<p>当支持用户登录后，就可以根据用户的认证状态分别显示不同的内容。</p>
<div class="highlight"><pre><span></span><code>from flask import session,request
@app.route(&#39;/hellotest&#39;)
def hellotest():
    name=request.args.get(&#39;name&#39;)
    if name is None:
        name=request.cookies.get(&#39;name&#39;,&#39;xixi&#39;)
    response=&#39;&lt;h1&gt;hello,%s&lt;/h1&gt;&#39;%name
    if &quot;logged_in&quot; in session:
        response +=&#39;YES&#39;
    else:
        response +=&#39;NO&#39;
    return response

from flask import redirect,session,url_for
@app.route(&#39;/logintest&#39;)
def logintest():
    session[&#39;logged_in&#39;]=True
    return redirect(url_for(&#39;hellotest&#39;))
</code></pre></div>

<p><img alt="image-20210107110319228" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107110319228.png" /></p>
<p>程序中的某些资源仅提供给登入的用户，比如管理后台，这时就可以通过判断session是否存在logged-in键来判断用户是否认证。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/admintest&#39;)
def admintest():
    if &#39;logged_in&#39; not in session:
        abort(403)
    return &#39;YES&#39;
</code></pre></div>

<p><img alt="image-20210107111453347" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107111453347.png" /></p>
<p>通过判断logged_in是否在session中，可以实现:如果用户已经认证，会返回一行提示文字，否则会返回403错误响应。
登出用户的logout视图也非常简单，登出账户对应的实际操作其实就是把代表用户认证的logged-in cookie删除，这通过session对象的pop方法实现。</p>
<div class="highlight"><pre><span></span><code>from flask import session,request
@app.route(&#39;/hellotest&#39;)
def hellotest():
    name=request.args.get(&#39;name&#39;)
    if name is None:
        name=request.cookies.get(&#39;name&#39;,&#39;xixi&#39;)
    response=&#39;&lt;h1&gt;hello,%s&lt;/h1&gt;&#39;%name
    if &quot;logged_in&quot; in session:
        response +=&#39;YES&#39;
    else:
        response +=&#39;NO&#39;
    return response

@app.route(&#39;/logouttest&#39;)
def logouttest():
    if &#39;logged_in&#39; in session:
        session.pop(&#39;logged_in&#39;)
    return redirect(url_for(&#39;hellotest&#39;))
</code></pre></div>

<p><img alt="image-20210107112917015" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107112917015.png" /></p>
<p><img alt="image-20210107112944962" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107112944962.png" /></p>
<p>默认情况下，session cookie会在用户关闭浏览器时删除。通过将session.permanent属性设为True可以将session的有效期延长为Flask. permanent_session_lifetime属性值对应的datetime.timedelta对象，也可通过配置变量PERMANENT_SESSION_LIFETIME设置，默认为31天。</p>
<h3 id="flask_7">Flask上下文变量<a class="headerlink" href="#flask_7" title="Permanent link">&para;</a></h3>
<p><img alt="image-20210107114435506" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107114435506.png" /></p>
<p>因为g存储在程序上下文中，而程序上下文会随着每一个请求的进入而激活，随着每一个请求的处理完毕而销毁，所以每次请求都会重设这个值。通常会使用它结合请求钩子来保存每个请求处理前所需要的全局变量，比如当前登入的用户对象，数据库连接等。在前面的示例中，在hello视图中从查询字符串获取name的值，如果每一个视图都需要这个值，那么就要在每个视图重复这行代码。借助g可以将这个操作移动到before_request处理函数中执行，然后保存到g的任意属性上。</p>
<div class="highlight"><pre><span></span><code>from flask import g
        @app.before_request
        def get_name():
            g.name = request.args.get(&#39;name&#39;)
</code></pre></div>

<h3 id="http-referer">HTTP referer<a class="headerlink" href="#http-referer" title="Permanent link">&para;</a></h3>
<p>HTTP referer(起源为referrer在HTTP规范中的错误拼写)是一个用来记录请求发源地址的HTTP首部字段(HTTP_REFERER)，即访问来源。当用户在某个站点单击链接，浏览器向新链接所在的服务器发起请求，<strong>请求的数据中包含的HTTP_REFERER字段记录了用户所在的原站点URL</strong>。
这个值通常会用来追踪用户，比如记录用户进入程序的外部站点，以此来更有针对性地进行营销。在Flask中,referer的值可以通过请求对象的referrer属性获取，即request.referrer(正确拼写形式)。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/tztest01&#39;)
def tztest01():
    response=&#39;there is test01,goto tztest03:&lt;a href=&quot;%s&quot;&gt;tztest03&lt;/a&gt;&#39;%url_for(&#39;tztest03&#39;)
    return response

@app.route(&#39;/tztest02&#39;)
def tztest02():
    response=&#39;there is test02,goto tztest03:&lt;a href=&quot;%s&quot;&gt;tztest03&lt;/a&gt;&#39;%url_for(&#39;tztest03&#39;)
    return response

@app.route(&#39;/tztest03&#39;)
def tztest03():
    #do something
    return  redirect(request.referrer)
</code></pre></div>

<p><img alt="image-20210107160232519" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107160232519.png" /></p>
<p>但是在很多种情况下，referrer字段会是空值，比如用户在浏览器的地址栏输入URL，或是用户出于保护隐私的考虑使用了防火墙软件或使用浏览器设置自动清除或修改了referrer字段。需要添加一个备选项。</p>
<div class="highlight"><pre><span></span><code>return  redirect(request.referrer or url_for(&#39;hellotest&#39;))
</code></pre></div>

<p>除了自动从referrer获取，另一种更常见的方式是在URL中手动加入包含当前页面URL的查询参数，这个查询参数一般命名为next。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/tztest04&#39;)
def tztest04():
    response=&#39;there is test04,goto tztest05:&lt;a href=&quot;%s&quot;&gt;tztest05&lt;/a&gt;&#39;%url_for(&#39;tztest03&#39;,next=request.full_path)
    return response

@app.route(&#39;/tztest05&#39;)
def tztest05():
    #do something
    return redirect(request.args.get(&#39;next&#39;))
</code></pre></div>

<p><img alt="image-20210107161424707" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210107161424707.png" /></p>
<p>在程序内部只需要使用相对URL，所以这里使用request.full_path获取当前页面的完整路径。在do_something视图中，获取这个next值，然后重定向到对应的路径。</p>
<h3 id="url_4">URL安全验证<a class="headerlink" href="#url_4" title="Permanent link">&para;</a></h3>
<p>安全问题不容小觑，鉴于referer和next容易被篡改的特性，如果不对这些值进行验证，则会形成开放重定向(Open Redirect)漏洞。
以URL中的next参数为例，next变量以查询字符串的方式写在URL里，因此任何人都可以发给某个用户一个包含next变量指向任何站点的链接。</p>
<div class="highlight"><pre><span></span><code>http://localhost:5000/do-something?next=http://helloflask.com
</code></pre></div>

<p>确保URL安全的关键就是判断URL是否属于程序内部，创建一个URL验证函数is_safe_url()，用来验证next变量值是否属于程序内部URL。</p>
<div class="highlight"><pre><span></span><code>def redirect_back(default=&#39;hellotest&#39;, **kwargs):
    for target in request.args.get(&#39;next&#39;), request.referrer:
        if not target:
            continue
        if is_safe_url(target):
            return redirect(target)
    return redirect(url_for(default, **kwargs))
</code></pre></div>

<h3 id="ajax">AJAX异步请求<a class="headerlink" href="#ajax" title="Permanent link">&para;</a></h3>
<p>在传统的Web应用中，程序的操作都是基于请求响应循环来实现的。每当页面状态需要变动，或是需要更新数据时，都伴随着一个发向服务器的请求。当服务器返回响应时，整个页面会重载，并渲染新页面。
这种模式会带来一些问题。首先，频繁更新页面会牺牲性能，浪费服务器资源，同时降低用户体验。另外，对于一些操作性很强的程序来说，重载页面会显得很不合理。比如做了一个Web计算器程序，所有的按钮和显示屏幕都很逼真，但当单击“等于”按钮时，要等到页面重新加载后才在显示屏幕上看到结果，这显然会严重影响用户体验。AJAX技术可以完美地解决这些问题。</p>
<p>AJAX指异步Javascript和XML ( Asynchronous Java Script AndXML)，它不是编程语言或通信协议，而是一系列技术的组合体。简单来说， AJAX基于XMLHttp Request( <a href="https://xhr.spec.whatwg.org/)可以在不重载页面的情况下和服务器进行数据交换">https://xhr.spec.whatwg.org/)可以在不重载页面的情况下和服务器进行数据交换</a>。加上Java Script和DOM (DocumentObject Model，文档对象模型)，就可以在接收到响应数据后局部更新页面。而XML指的则是数据的交互格式，也可以是纯文本( Plain Text) . HTML或JSON。顺便说一句，XMLHttp Request不仅支持HTTP协议，还支持FILE和FTP协议。</p>
<h3 id="jqueryajax">使用jQuery发送AJAX请求<a class="headerlink" href="#jqueryajax" title="Permanent link">&para;</a></h3>
<p>jQuery是流行的Java Script库，它包装了Java Script，可以通过更简单的方式编写Java Script代码。对于AJAX，它提供了多个相关的方法，使用它可以很方便地实现AJAX操作。更重要的是，jQuery处理了不同浏览器的AJAX兼容问题，只需要编写一套代码，就可以在所有主流的浏览器正常运行。</p>
<p>使用jQuery实现AJAX并不是必须的，可以选择使用原生的XMLHttp Request、其他Java Script框架内置的AJAX接口，或是使用更新的Fetch APl ( <a href="https://fetch.spec.whatwg.org/)来发送异步请求">https://fetch.spec.whatwg.org/)来发送异步请求</a>。
在示例程序中，将使用全局jQuery函数ajax()发送AJAX请求。ajax()函数是底层函数，有丰富的自定义配置。以下是ajax()函数支持的参数。</p>
<p><img alt="image-20210111141336168" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210111141336168.png" /></p>
<h3 id="_14">返回局部数据<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<h4 id="html_1">纯文本或局部HTML模板<a class="headerlink" href="#html_1" title="Permanent link">&para;</a></h4>
<p>纯文本可以在Java Script用来直接替换页面中的文本值，而局部HTML则可以直接到插入页面中，比如返回评论列表：</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/comments/&lt;int:post_id&gt;&#39;)
        def get_comments(post_id):
            ...
            return render_template(&#39;comments.html&#39;)
</code></pre></div>

<h4 id="json_1">JSON数据<a class="headerlink" href="#json_1" title="Permanent link">&para;</a></h4>
<p>JSON数据可以在Java Script中直接操作：</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/profile/&lt;int:user_id&gt;&#39;)
        def get_profile(user_id):
            ...
            return jsonify(username=username, bio=bio)
</code></pre></div>

<h4 id="_15">空值<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>有些时候，程序中的某些接收AJAX请求的视图并不需要返回数据给客户端，比如用来删除文章的视图。这时可以直接返回空值，并将状态码指定为204(表示无内容)，比如:</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/post/delete/&lt;int:post_id&gt;&#39;, methods=[&#39;DELETE&#39;])
        def delete_post(post_id):
            ...
            return &#39;&#39;, 204
</code></pre></div>

<h4 id="_16">异步加载文章示例<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>在示例程序的对应页面中，将显示一篇很长的虚拟文章，文章正文下方有一个“加载更多”按钮，当加载按钮被单击时，会发送一个AJAX请求获取文章的更多内容并直接动态插入到文章下方。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/posttest&#39;)
def posttest():
    post_body=generate_lorem_ipsum(n=2)#生成两段随机文本
    return &#39;&#39;&#39;
    &lt;h1&gt;a very long post&lt;/h1&gt;
    &lt;div class=&quot;body&quot;&gt;%s&lt;/div&gt;
    &lt;button id=&quot;load&quot;&gt;load more&lt;/button&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){
        $(&#39;#load&#39;).click(function(){
            $.ajax({
                url:&#39;/moretest&#39;,        //目标URL
                type:&#39;get&#39;,             //请求方法
                success:function(data){ //返回2xx响应后触发的回调函数
                $(&#39;.body&#39;).append(data);//将返回的响应插入页面中
                }
            })
        })
    })
    &lt;/script&gt;
    &#39;&#39;&#39;%post_body


@app.route(&#39;/moretest&#39;)
def moretest():
    return generate_lorem_ipsum(n=1)
</code></pre></div>

<h3 id="http_2">http服务端推送<a class="headerlink" href="#http_2" title="Permanent link">&para;</a></h3>
<p>实现服务器端推送的一系列技术被合称为HTTP Server Push (HTTP服务器端推送)，目前常用的推送技术如：</p>
<p><img alt="image-20210113114457698" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210113114457698.png" /></p>
<h3 id="web">web安全防范<a class="headerlink" href="#web" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/students&#39;)
        def bobby_table():
            password = request.args.get(&#39;password&#39;)
            cur = db.execute(&quot;SELECT ＊ FROM students WHERE password=&#39;%s&#39;; &quot; % password)
            results = cur.fetchall()
            return results
</code></pre></div>

<p>在实际应用中，敏感数据需要通过表单提交的POST请求接收，这里为了便于演示,通过查询参数接收。通过查询字符串获取用户输入的查询参数，并且不经过任何处理就使用字符串格式化的方法拼接到SQL语句中。在这种情况下，如果攻击者输入的password参数值为“" or 1=1--”，即<code>http://example.com/students?password=' or 1=1--</code>，那么最终视图函数中被执行的SQL语句将变为:</p>
<div class="highlight"><pre><span></span><code> SELECT ＊ FROM students WHERE password=&#39;&#39; or 1=1--; &#39;
</code></pre></div>

<p>这时会把students表中的所有记录全部查询并返回，也就意味着所有的记录都被攻击者窃取了。更可怕的是，如果攻击者将password参数的值设为"; drop table users;--”，那么查询语句就会变成：</p>
<div class="highlight"><pre><span></span><code>SELECT ＊ FROM students WHERE password=&#39;&#39;; drop table students; --;
</code></pre></div>

<p>执行这个语句会把students表中的所有记录全部删除掉。</p>
<p>反射型XSS又称为非持久型XSS (Non-Persistent XSS)。当某个站点存在XSS漏洞时，这种攻击会通过URL注入攻击脚本，只有当用户访问这个URL时才会执行攻击脚本。在本章前面介绍查询字符串和cookie时引入的示例就包含反射型XSS漏洞，如：</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/escapetest&#39;)
def escapetest():
    name=request.args.get(&#39;name&#39;)
    return &quot;&lt;h1&gt;hello,%s&lt;/h1&gt;&quot;%name
</code></pre></div>

<p>这个视图函数接收用户通过查询字符串传入的数据，未做任何处理就把它直接插入到返回的响应主体中，返回给客户端。如果某个用户输入了一段JavaScript代码作为查询参数name的值，如：</p>
<div class="highlight"><pre><span></span><code>http://127.0.0.1:5000/escapetest?name=&lt;script&gt;alert(&#39;bingo!&#39;);&lt;/script&gt;
</code></pre></div>

<p><img alt="image-20210113142719767" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210113142719767.png" /></p>
<p>能够执行alert()函数就意味着通过这种方式可以执行任意Java Script代码。即攻击者通过Java Script几乎能够做任何事情:窃取用户的cookie和其他敏感数据，重定向到钓鱼网站，发送其他请求，执行诸如转账、发布广告信息、在社交网站关注某个用户等。</p>
<h3 id="_17">防范措施<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<h4 id="html_2">html转义<a class="headerlink" href="#html_2" title="Permanent link">&para;</a></h4>
<p>这里的转义和Python中的概念相同，即消除代码执行时的歧义，也就是把变量标记的内容标记为文本，而不是HTML代码。具体来说，这会把变量中与HTML相关的符号转换为安全字符，以避免变量中包含影响页面输出的HTML标签或恶意的Java Script代码。</p>
<p>比如，可以使用Jinja2提供的escape()函数对用户传入的数据进行转义：</p>
<div class="highlight"><pre><span></span><code>from jinja2 import escape
@app.route(&#39;/escapetest&#39;)
def escapetest():
    name=request.args.get(&#39;name&#39;)
    return &quot;&lt;h1&gt;hello,%s&lt;/h1&gt;&quot;%escape(name)
</code></pre></div>

<p><img alt="image-20210113143038370" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210113143038370.png" /></p>
<p>以某个程序的用户资料页面为例，来演示一下转义无法完全避免的XSS攻击。程序允许用户输入个人资料中的个人网站地址，通过下面的方式显示在资料页面中：</p>
<div class="highlight"><pre><span></span><code>&lt;a href=&quot;{{ url }}&quot;&gt;Website&lt;/a&gt;
</code></pre></div>

<p>其中{{ url }}部分表示会被替换为用户输入的url变量值。如果不对URL进行验证，那么用户就可以写入Java Script代码，比如“javascript:alert('Bingo!');”。因为这个值并不包含会被转义的&lt;和&gt;。最终页面上的链接代码会变为：</p>
<div class="highlight"><pre><span></span><code>&lt;a href=&quot;javascript:alert(&#39; Bingo! &#39;); &quot;&gt;Website&lt;/a&gt;
</code></pre></div>

<p>当用户单击这个链接时，就会执行被注入的攻击代码。
另外，程序还允许用户自己设置头像图片的URL。这个图片通过下面的方式显示：</p>
<div class="highlight"><pre><span></span><code>&lt;img src=&quot;{{ url }}&quot;&gt;
</code></pre></div>

<p>类似的，f url }}部分表示会被替换为用户输入的url变量值。如果不对输入的URL进行验证，那么用户可以将url设为“123" onerror="alert('Bingo! ')”，最终的<img>标签就会变为：</p>
<div class="highlight"><pre><span></span><code>&lt;img src=&quot;123&quot; onerror=&quot;alert(&#39; Bingo! &#39;)&quot;&gt;
</code></pre></div>

<p>在这里因为src中传入了一个错误的URL，浏览器便会执行onerror属性中设置的JavaScript代码。</p>
<h2 id="_18">模板<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h2>
<p>前面示例中，当用户访问程序的根地址时，视图函数会向客户端返回一行HTML代码。然而，一个完整的HTML页面往往需要几十行甚至上百行代码，如果都写到视图函数里，那可真是个噩梦。这样的代码既不简洁也难于维护，正确的做法是把HTML代码存储在单独的文件中，以便让程序的业务逻辑和表现逻辑分离，即控制器和用户界面的分离。</p>
<p>在动态Web程序中，视图函数返回的HTML数据往往需要根据相应的变量(比如查询参数）动态生成。当HTML代码保存到单独的文件中时，没法再使用字符串格式化或拼接字符串的方式来在HTML代码中插入变量，这时需要使用模板引擎( templateengine)。借助模板引擎，可以在HTML文件中使用特殊的语法来标记出变量，这类包含固定内容和动态部分的可重用文件称为模板(template)。</p>
<p>模板引擎的作用就是读取并执行模板中的特殊语法标记，并根据传入的数据将变量替换为实际值，输出最终的HTML页面，这个过程被称为渲染（rendering)。Flask默认使用的模板引擎是Jinja2，它是一个功能齐全的Python模板引擎，除了设置变量，还允许在模板中添加if判断，执行for迭代，调用函数等，以各种方式控制模板的输出。对于Jinja2来说，模板可以是任何格式的纯文本文件，比如HTML、XML、CSV、La TeX等。在这一章，会学习Jinja2模板引擎的基本用法和一些常用技巧。</p>
<h3 id="jinja2">Jinja2常见的定界符<a class="headerlink" href="#jinja2" title="Permanent link">&para;</a></h3>
<h4 id="_19">语句<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>for循环、if判断等：</p>
<div class="highlight"><pre><span></span><code>{% ...  %}
</code></pre></div>

<h4 id="_20">表达式<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>字符串、变量、函数等：</p>
<div class="highlight"><pre><span></span><code>{{ ... }}
</code></pre></div>

<h4 id="_21">注释<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>{# ... #}
</code></pre></div>

<p>另外，在模板中，Jinja2支持使用“.”获取变量的属性，比如user字典中的username键值通过“.”获取，即user.username，在效果上等同于user['username']。</p>
<h3 id="_22">模板语法<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>利用Jinja2这样的模板引擎，可以将一部分的程序逻辑放到模板中去。简单地说，可以在模板中使用Python语句和表达式来操作数据的输出。但需要注意的是，Jinja2并不支持所有Python语法。而且出于效率和代码组织等方面的考虑，应该适度使用模板，仅把和输出控制有关的逻辑操作放到模板中。</p>
<p>Jinja2允许在模板中使用大部分Python对象，比如字符串、列表、字典、元组、整型、浮点型、布尔值。它支持基本的运算符号(+、-、*、/等）、比较符号（比如==、!=等）、逻辑符号( and、 or、not和括号）以及in、 is、None和布尔值（True、False)。</p>
<p>Jinja2提供了多种控制结构来控制模板的输出，其中for和if是最常用的两种。在Jinja2里，语句使用{% ...%}标识，尤其需要注意的是，在语句结束的地方，必须添加结束标签。</p>
<div class="highlight"><pre><span></span><code>{% if user.bio %}
&lt;i&gt;{{ user.bio }}&lt;/i&gt;
{% else %}
&lt;i&gt;this user has not provided a bio&lt;/i&gt;
{% endif %}
</code></pre></div>

<p>for语句迭代：</p>
<div class="highlight"><pre><span></span><code>{% for movie in movies %}
&lt;li&gt;{{ movie.name }} - {{ movie.year }}&lt;/li&gt;
{% endfor %}
</code></pre></div>

<p>常用的for循环变量</p>
<p><img alt="image-20210128091607292" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210128091607292.png" /></p>
<h3 id="_23">渲染模板<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<p>渲染一个模板，就是执行模板中的代码，并传入所有在模板中使用的变量，渲染后的结果就是要返回给客户端的HTML响应。在视图函数中渲染模板时，并不直接使用Jinja2提供的函数，而是使用Flask提供的渲染函数render_template()。</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/watchlist&#39;)
def watchlist():
    return render_template(&#39;watchlist.html&#39;,user=user,movies=movies)
</code></pre></div>

<p>在render_template()函数中，首先传入模板的文件名作为参数。Flask会在程序根目录下的templates文件夹里寻找模板文件，所以这里传入的文件路径是相对于templates根目录的。除了模板文件路径，还以关键字参数的形式传入了模板中使用的变量值，以user为例:左边的user表示传入模板的变量名称，右边的user则是要传入的对象。</p>
<p>除了render_template()函数，Flask还提供了一个render_template_string()函数用来渲染模板字符串。</p>
<p>如果想传入函数在模板中调用，那么需要传入函数对象本身，而不是函数调用(函数的返回值)，所以仅写出函数名称即可。当把函数传入模板后，可以像在Python脚本中一样通过添加括号的方式调用，而且也可以在括号中传入参数。</p>
<h3 id="_24">模板辅助工具<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<p>1、模板中定义变量，使用set标签</p>
<div class="highlight"><pre><span></span><code>{% set navigation = [(&#39;/&#39;, &#39;Home&#39;), (&#39;/about&#39;, &#39;About&#39;)] %}
</code></pre></div>

<p>也可以将一部分模板数据定义为变量，使用set和endset标签声明开始和结束:</p>
<div class="highlight"><pre><span></span><code>{% set navigation %}
            &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;
            &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;
{% endset %}
</code></pre></div>

<p>2、内置上下文，Flask提供了一些内置变量，可以直接使用</p>
<p><img alt="image-20210128105925871" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210128105925871.png" /></p>
<p>如果多个模板都需要使用同一变量，那么比起在多个视图函数中重复传入，更好的方法是能够设置一个模板全局变量。Flask提供了一个app.context_processor装饰器，可以用来注册模板上下文处理函数，它可以帮完成统一传入变量的工作。模板上下文处理函数需要返回一个包含变量键值对的字典。</p>
<div class="highlight"><pre><span></span><code>@app.context_processor
        def inject_foo():
            foo = &#39;I am foo.&#39;
            return dict(foo=foo)  # 等同于return {&#39;foo&#39;: foo}
</code></pre></div>

<p>当调用render_template()函数渲染任意一个模板时，所有使用app.context_processor装饰器注册的模板上下文处理函数（包括Flask内置的上下文处理函数）都会被执行，这些函数的返回值会被添加到模板中，因此可以在模板中直接使用foo变量。</p>
<p>3、全局变量</p>
<p>Jinja2默认的全局函数</p>
<p><img alt="image-20210128112544688" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210128112544688.png" /></p>
<p>Flask全局函数</p>
<p><img alt="image-20210128112631351" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210128112631351.png" /></p>
<p>Flask除了把g、session、config、 request对象注册为上下文变量，也将它们设为全局变量，因此可以全局使用。</p>
<p>4、自定义全局函数</p>
<p>除了使用app.context_processor注册模板上下文处理函数来传入函数，也可以使用app. template_global装饰器直接将函数注册为模板全局函数。比如把bar()函数注册为模板全局函数。</p>
<div class="highlight"><pre><span></span><code>@app.template_global
def bar():
    return &quot;I am bar&quot;
</code></pre></div>

<p>5、过滤器</p>
<p>在Jinja2中，过滤器（(filter）是一些可以用来修改和过滤变量值的特殊函数，过滤器和变量用一个竖线（管道符号）隔开，需要参数的过滤器可以像函数一样使用括号传递。</p>
<div class="highlight"><pre><span></span><code>&lt;h3&gt;{{ user.username }}&#39;s movies list({{ movies|length }}):&lt;/h3&gt;
</code></pre></div>

<p>该方法类似于在python中调用len(movies)。</p>
<p>另一种用法是将过滤器作用于一部分模板数据，使用filter标签和endfilter标签声明开始和结束。下面使用upper过滤器将一段文字转换为大写:</p>
<div class="highlight"><pre><span></span><code>{% filter upper %}
            This text becomes uppercase.
{% endfilter %}
</code></pre></div>

<p>6、内置过滤器</p>
<p>Jinja2提供的内置过滤器</p>
<p><img alt="image-20210128113405932" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210128113405932.png" /></p>
<p>另外，过滤器可以叠加使用，下面的示例为name变量设置默认值，并将其标题化:</p>
<div class="highlight"><pre><span></span><code>&lt;h1&gt;Hello, {{ name|default(’陌生人’)|title }}! &lt;/h1&gt;
</code></pre></div>

<p>在确保变量值安全的情况下，这通常意味着已经对用户输入的内容进行了“消毒”处理。这时如果想避免转义，将变量作为HTML解析，可以对变量使用safe过滤器:</p>
<div class="highlight"><pre><span></span><code>{{ sanitized_text|safe }}
</code></pre></div>

<p>另一种将文本标记为安全的方法是在渲染前将变量转换为Markup对象:</p>
<p>7、自定义过滤器</p>
<p>使用app.template_filter()装饰器可以注册自定义过滤器。</p>
<div class="highlight"><pre><span></span><code>from flask import Markup
@app.template_filter()
def musical(s):
    return s + Markup(&#39; &amp;#9835; &#39;)

#或
app.add_template_filter(musical)
</code></pre></div>

<p>创建的musical过滤器会在被过滤的变量字符后面添加一个音符(single bar note）图标，因为音符通过HTML实体\&#9835;表示，使用Markup类将它标记为安全字符。在使用时和其他过滤器用法相同:</p>
<div class="highlight"><pre><span></span><code>{{ name|musical }}
</code></pre></div>

<p>8、测试器</p>
<p>在Jinja2中，测试器(Test)是一些用来测试变量或表达式，返回布尔值(True或False）的特殊函数。比如，number测试器用来判断一个变量或表达式是否是数字，使用is连接变量和测试器:</p>
<div class="highlight"><pre><span></span><code>{% if age is number %}
    {{ age ＊ 365 }}
{% else %}
无效的数字。
{% endif %}
</code></pre></div>

<p>9、常用的内置测试器</p>
<p><img alt="image-20210129150607919" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210129150607919.png" /></p>
<p>在使用测试器时，is的左侧是测试器函数的第一个参数(value) ,其他参数可以添加括号传入，也可以在右侧使用空格连接，以sameas为例:</p>
<div class="highlight"><pre><span></span><code> {% if foo is sameas(bar) %}
 #等同于：
 {% if foo is sameas bar %}
</code></pre></div>

<p>10、自定义测试器</p>
<div class="highlight"><pre><span></span><code>@app.template_test()
def baz(n):
    if n == &#39;baz&#39;:
        return True
    return False
</code></pre></div>

<h3 id="_25">模板环境对象<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<p>在Jinja2中，渲染行为由jinja2.Enviroment类控制，所有的配置选项、上下文变量、全局函数、过滤器和测试器都存储在Enviroment实例上。当与Flask结合后，并不单独创建Enviroment对象，而是使用Flask创建的Enviroment对象，它存储在appjinja_env属性上。
在程序中，可以使用app.jinja_env更改Jinja2设置。比如，可以自定义所有的定界符。下面使用variable_start_string和variable_end_string分别自定义变量定界符的开始和结束符号:</p>
<div class="highlight"><pre><span></span><code>app = Flask(__name__)
app.jinja_env.variable_start_string = &#39;[[&#39;
app.jinja_env.variable_end_string = &#39;]]&#39;
</code></pre></div>

<p>模板环境中的全局函数、过滤器和测试器分别存储在Enviroment对象的globals、filters和tests属性中，这三个属性都是字典对象。除了使用Flask提供的装饰器和方法注册自定义函数，也可以直接操作这三个字典来添加相应的函数或变量，这通过向对应的字典属性中添加一个键值对实现，传入模板的名称作为键，对应的函数对象或变量作为值。</p>
<p>1、添加自定义全局对象</p>
<p>和app.template_global()装饰器不同，直接操作globals字典允许传入任意Python对象，而不仅仅是函数，类似于上下文处理函数的作用。下面的代码使用app.jinja_env.globals分别向模板中添加全局函数bar和全局变量foo:</p>
<div class="highlight"><pre><span></span><code>def bar():
    return &quot;I am bar&quot;
foo=&quot;I am foo&quot;

app.jinja_env.globals[&#39;bar&#39;]=bar
app.jinja_env.globals[&#39;foo&#39;]=foo
</code></pre></div>

<p>全局变量或函数的使用：</p>
<div class="highlight"><pre><span></span><code>{{ bar() }} and {{ foo }}
</code></pre></div>

<p>2、添加自定义过滤器</p>
<div class="highlight"><pre><span></span><code>def musical(s):
    return s +Markup(&#39;&amp;#9835;&#39;)
app.jinja_env.filters[&#39;musical&#39;]=musical
</code></pre></div>

<p>3、添加自定义测试器</p>
<div class="highlight"><pre><span></span><code>def baz(n):
    if n == &#39;baz&#39;:
        return True
    else:
        return  False
app.jinja_env.tests[&#39;baz&#39;]=baz
</code></pre></div>

<h3 id="_26">模板结构组织<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>1、局部模板</p>
<p>web程序中，为每一类页面独立编写一个模板，比如主页模板、用户资料模板。模板可以直接在视图函数中渲染并作为HTML响应主体。除了这类模板，还会用到另一类非独立模板，这类模板通常被称为局部模板或次模板，因为它们仅包含部分代码，所以不会在视图函数中直接渲染它，而是插入到其他独立模板中。</p>
<p>当程序中的某个视图用来处理AJAX请求时，返回的数据不需要包含完整的HTML结构，这时就可以返回渲染后的局部模板。</p>
<p>当多个独立模板中都会使用同一块HTML代码时，可以把这部分代码抽离出来，存储到局部模板中。这样一方面可以避免重复，另一方面也可以方便统一管理。比如，多个页面中都要在页面顶部显示一个提示条，这个横幅可以定义在局部模板_banner.html中。</p>
<p>使用include标签来插入一个局部模板，这会把局部模板的全部内容插在使用include标签的位置。比如，在其他模板中，可以在任意位置使用下面的代码插入_banner.html的内容:</p>
<div class="highlight"><pre><span></span><code>{% include &#39;_banner.html&#39; %}
</code></pre></div>

<p><strong>为了和普通模板区分开，局部模板的命名通常以一个下划线开始。</strong></p>
<p>2、宏</p>
<p>宏(macro)是Jinja2提供的一个非常有用的特性，它类似Python中的函数。使用宏可以把一部分模板代码封装到宏里，使用传递的参数来构建内容，最后返回构建后的内容。在功能上，它和局部模板类似，都是为了方便代码块的重用。
为了便于管理，可以把宏存储在单独的文件中，这个文件通常命名为macros.html或_macors.html。在创建宏时，使用macro和endmacro标签声明宏的开始和结束。在开始标签中定义宏的名称和接收的参数。</p>
<div class="highlight"><pre><span></span><code>{% macro qux(amount=1) %}
            {% if amount == 1 %}
                I am qux.
            {% elif amount &gt; 1 %}
                We are quxs.
            {% endif %}
        {% endmacro %}
</code></pre></div>

<p>使用时，需要像从Python模块中导入函数一样使用import语句导入它，然后作为函数调用，传入必要的参数。</p>
<div class="highlight"><pre><span></span><code>{% from &#39;macros.html&#39; import qux %}
          .
        {{ qux(amount=5) }}
</code></pre></div>

<p>另外，在使用宏时需要注意上下文问题。在Jinja2中，出于性能的考虑，并且为了让这一切保持显式，默认情况下包含（include)一个局部模板会传递当前上下文到局部模板中，但导入(import)却不会。具体来说，当使用render_template()函数渲染一个foo.html模板时，这个foo.html的模板上下文中包含下列对象:</p>
<div class="highlight"><pre><span></span><code>1、Flask使用内置的模板上下文处理函数提供的g、session.config、request。
2、扩展使用内置的模板上下文处理函数提供的变量。
3、自定义模板上下文处理器传入的变量。
4、使用render_template()函数传入的变量。
5、Jinja2和Flask内置及自定义全局对象。
6、Jinja2内置及自定义过滤器。
7、Jinja2内置及自定义测试器。
</code></pre></div>

<p>使用include标签插入的局部模板(比如_banner.html)同样可以使用上述上下文中的变量和函数。而导入另一个并非被直接渲染的模板（比如macros.html)时，这个模板仅包含下列这些对象:</p>
<div class="highlight"><pre><span></span><code>1、Jinja2和Flask内置的全局函数和自定义全局函数。
2、Jinja2内置及自定义过滤器。
3、Jinja2内置及自定义测试器。
</code></pre></div>

<h3 id="_27">模板继承<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p>1、基模板</p>
<p>基模板存储了程序页面的固定部分，通常被命名为base.html或layout.html。示例程序中的基模板base.html中包含了一个基本的HTML结构，还添加了一个简单的导航条和页脚：</p>
<div class="highlight"><pre><span></span><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    {% block head %}
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;{% block title %}Template - HelloFlask{% endblock %}&lt;/title&gt;
        &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;{{ url_for(&#39;static&#39;, filename=&#39;favicon.ico&#39;) }}&quot;&gt;
        {% block styles %}
            &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{ url_for(&#39;static&#39;, filename=&#39;style.css&#39; ) }}&quot;&gt;
        {% endblock %}
    {% endblock %}
&lt;/head&gt;
&lt;body&gt;
&lt;nav&gt;
    &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;{{ url_for(&#39;index&#39;) }}&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
    {% for message in get_flashed_messages() %}
        &lt;div class=&quot;alert&quot;&gt;{{ message }}&lt;/div&gt;
    {% endfor %}
    {% block content %}{% endblock %}
&lt;/main&gt;
&lt;footer&gt;
    {% block footer %}
        &lt;small&gt; &amp;copy; 2021 &lt;a href=&quot;http://www.baidu.com&quot; title=&quot;Written by chyuhung&quot;&gt;chyuhung&lt;/a&gt; /
            &lt;a href=&quot;https://github.com/chyuhung/helloflask&quot; title=&quot;Fork me on GitHub&quot;&gt;GitHub&lt;/a&gt; /
            &lt;a href=&quot;http://helloflask.com&quot; title=&quot;A HelloFlask project&quot;&gt;HelloFlask&lt;/a&gt;
        &lt;/small&gt;
    {% endblock %}
&lt;/footer&gt;
{% block scripts %}{% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>

<p>当子模板继承基模板后，子模板会自动包含基模板的内容和结构。为了能够让子模板方便地覆盖或插入内容到基模板中，需要在基模板中定义块(block)，在子模板中可以通过定义同名的块来执行继承操作。</p>
<p>块的开始和结束分别使用block和endblock标签声明，而且块之间可以嵌套。在这个基模板中，创建了六个块: head、 title、styles、content、footer和scripts，分别用来划分不同的代码。其中,head块表示<head>标签的内容，title表示<title>标签的内容，content块表示页面主体内容，footer表示页脚部分，styles块和scripts块，则分别用来包含CSS文件和Java Script文件引用链接或页内的CSS和Java Script代码。</p>
<p>块名称可以随意指定，而且并不是必须的。可以按照需要设置块，如果只需要让子模板添加主体内容，那么仅定义一个content块就足够了。
以content块为例，模板继承示意图如图3-2所示。</p>
<p><img alt="image-20210129163338166" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210129163338166.png" /></p>
<p>为了避免块的混乱，块的结束标签可以指明块名，同时要确保前后名称一致。比如:</p>
<div class="highlight"><pre><span></span><code>{% block body %}
          .
{% endblock body %}
</code></pre></div>

<p>2、编写子模板</p>
<p>因为基模板中定义了HTML的基本结构，而且包含了页脚等固定信息，在子模板中不再需要定义这些内容，只需要对特定的块进行修改。这时可以修改前面创建的电影清单模板watchlist.html和主页模板index.html，将这些子模板的通用部分合并到基模板中，并在子模板中定义块来组织内容，以便在渲染时将块中的内容插入到基模板的对应位置。以index.html为例:</p>
<p><strong>使用extends标签声明扩展基模板，它告诉模板引擎当前模板派生自base.html。extends必须是子模板的第一个标签。</strong></p>
<div class="highlight"><pre><span></span><code>{% extends &#39;base.html&#39; %}
{% from &#39;macros.html&#39; import qux %}

{% block content %}
{% set name=&#39;baz&#39; %}
&lt;h1&gt;Template&lt;/h1&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;{{ url_for(&#39;watchlist&#39;) }}&quot;&gt;Watchlist&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;Filter: {{ foo|musical }}&lt;/li&gt;
    &lt;li&gt;Global: {{ bar() }}&lt;/li&gt;
    &lt;li&gt;Test: {% if name is baz %}I am baz.{% endif %}&lt;/li&gt;
    &lt;li&gt;Macro: {{ qux(amount=1) }}&lt;/li&gt;
&lt;/ul&gt;
{% endblock %}
</code></pre></div>

<h3 id="_28">子模板对父模板的操作<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h3>
<p>1、覆盖内容</p>
<p>当在子模板里创建同名的块时，会使用子块的内容覆盖父块的内容。比如在子模板index.html中定义了title块，内容为Home，这会把块中的内容填充到基模板里的title块的位置，最终渲染为<title>Home</title>, content块的效果同理。</p>
<p>2、追加内容</p>
<p>如果想要向基模板中的块追加内容，需要使用Jinja2提供的super()函数进行声明，这会向父块添加内容。比如，下面的示例向基模板中的styles块追加了一行<style>样式定义:</p>
<div class="highlight"><pre><span></span><code> {% block styles %}
 {{ super() }}
 &lt;style&gt;
     .foo {
        color: red;
     }
 &lt;/style&gt;
 {% endblock %}
</code></pre></div>

<p>当子模板被渲染时，它会继承基模板的所有内容，然后根据定义的块进行覆盖或追加操作。</p>
<p>3、空白控制</p>
<p>在实际输出的HTML文件中，模板中的Jinja2语句、表达式和注释会保留移除后的空行，如果想在渲染时自动去掉这些空行，可以在定界符内侧添加减号。比如，{%-endfor %}会移除该语句前的空白，同理，在右边的定界符内侧添加减号将移除该语句后的空白:</p>
<div class="highlight"><pre><span></span><code>{% if user.bio -%}
    &lt;i&gt;{{ user.bio }}&lt;/i&gt;
{% else -%}
    &lt;i&gt;This user has not provided a bio.&lt;/i&gt;
{%- endif %}
</code></pre></div>

<p>除了在模板中使用减号来控制空白外，也可以使用模板环境对象提供的trim_blocks和lstrip_blocks属性设置，前者用来删除Jinja2语句后的第一个空行，后者则用来删除Jinja2语句所在行之前的空格和制表符(tabs) :</p>
<div class="highlight"><pre><span></span><code>app.jinja_env.trim_blocks = True
app.jinja_env.lstrip_blocks = True
</code></pre></div>

<p>4、加载静态文件</p>
<p>一个Web项目不仅需要HTML模板，还需要许多静态文件，比如CSS、Java Script文件、图片以及音频等。在Flask程序中，默认需要将静态文件存储在与主脚本（包含程序实例的脚本)同级目录的static文件夹中。
为了在HTML文件中引用静态文件，需要使用url_for()函数获取静态文件的URL。Flask内置了用于获取静态文件的视图函数，端点值为static，它的默认URL规则为/static/\&lt;path:filename>,URL变量filename是相对于static文件夹根目录的文件路径。</p>
<p>在示例程序的static目录下保存了一个头像图片avatar.jpg，可以通过url_for('static', filename='avatar.jpg')获取这个文件的URL，这个函数调用生成的URL为/static/avatar.jpg，在浏览器中输入http://localhost:5000/static/avatar.jpg即可访问图片
。在模板watchlist2.html里，在用户名的左侧添加了这个图片，使用url_for()函数生成图片src属性所需的图片URL，如下所示:</p>
<div class="highlight"><pre><span></span><code>&lt;img src=&quot; {{ url_for(&#39;static&#39;,filename=&#39;avatar.jpg&#39;) }}&quot;,width=&quot;50&quot;&gt;
</code></pre></div>

<p>另外，还创建了一个存储CSS规则的styles.css文件，使用下面的方式在模板中加载这个文件：</p>
<div class="highlight"><pre><span></span><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{ url_for(&#39;static&#39;,filename=&#39;style.css&#39;) }}&quot;&gt;
</code></pre></div>

<p>5、添加Favicon</p>
<p>favicon.ico文件指的是Favicon ( favorite icon，收藏夹头像/网站头像)，又称为shortcut icon、tab icon、website icon或是bookmark icon。
顾名思义，这是一个在浏览器标签页、地址栏和书签收藏夹等处显示的小图标，作为网站的特殊标记。浏览器在发起请求时，会自动向根目录请求这个文件，在前面的示例程序中，没有提供这个文件，所以才会产生404记录。</p>
<p>要想为Web项目添加Favicon，要先有一个Favicon文件，并放置到static目录下。它通常是一个宽高相同的ICO格式文件，命名为favicon.ico。</p>
<p>Flask中静态文件的默认路径为/static/filename，为了正确返回Favicon，可以显式地在HTML页面中声明Favicon的路径。首先可以在\&lt;head>部分添加一个\&lt;link>元素，然后将rel属性设置为icon，如下所示：</p>
<div class="highlight"><pre><span></span><code>&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;{{ url_for(&#39;static&#39;,filename=&#39;favicon.ico&#39;) }}&quot;&gt;
</code></pre></div>

<h3 id="css">CSS框架<a class="headerlink" href="#css" title="Permanent link">&para;</a></h3>
<p>在编写Web程序时，手动编写CSS比较麻烦，更常见的做法是使用CSS框架来为程序添加样式。CSS框架内置了大量可以直接使用的CSS样式类和Java Script函数，使用它们可以非常快速地让程序页面变得美观和易用，同时也可以定义自己的CSS文件来进行补充和调整。以Bootstrap ( <a href="http://getbootstrap.com/">http://getbootstrap.com/</a>)）为例，需要访问Bootstrap的下载页面( <a href="http://getbootstrap.com/docs/4.0/getting-started/download/)下载相应的资源文件">http://getbootstrap.com/docs/4.0/getting-started/download/)下载相应的资源文件</a>，然后分类别放到static目录下。</p>
<p>Bootstrap是最流行的开源前端框架之一，它有浏览器支持广泛、响应式设计等特点。使用它可以快速搭建美观、现代的网页。Bootstrap的官方文档(<a href="http://getbootstrap.com/docs/">http://getbootstrap.com/docs/</a>）提供了很多简单易懂的示例代码。
通常情况下，CSS和JavaScript的资源引用会在基模板中定义，具体方式和加载自定义的styles.css文件相同：</p>
<div class="highlight"><pre><span></span><code>       ...
        {% block styles %}
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for(&#39;static&#39;, filename=&#39;css/bootstrap.min.css&#39;) }}&quot;&gt;
        {% endblock %}
          .
        {% block scripts %}
            &lt;script src=&quot;{{ url_for(&#39;static&#39;, filename=&#39;js/jquery.min.js&#39;) }}&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;{{ url_for(&#39;static&#39;, filename=&#39;js/popper.min.js&#39;) }}&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;{{ url_for(&#39;static&#39;, filename=&#39;js/bootstrap.min.js&#39;) }}&quot;&gt;&lt;/script&gt;
        {% endblock %}
          ...
</code></pre></div>

<p>如果不使用Bootstrap提供的Java Script功能，那么也可以不加载。另外，Bootstrap所―依赖的j Query (<a href="https://jquery.com/)和Popper.js(https://popper.js.org/">https://jquery.com/)和Popper.js(https://popper.js.org/</a>）需要单独下载，这三个Java Script文件在引入时要按照j Query→Popper.js→Boostrap的顺序引入。</p>
<p>虽然建议在开发时统一管理静态资源，如果想简化开发过程，那么从CDN加载是更方便的做法。从CND加载时，只需要将相应的URL替换为CDN提供的资源URL，比如：</p>
<div class="highlight"><pre><span></span><code>        ...
        {% block styles %}
            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/
                css/bootstrap.min.css&quot;&gt;
        {% endblock %}
          ...
        {% block scripts %}
            &lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.slim.min.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/
                popper.min.js&quot;&gt;&lt;/script&gt;
            &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
        {% endblock %}
          ...
</code></pre></div>

<h3 id="_29">使用宏加载静态资源<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h3>
<p>为了方便加载静态资源，可以创建一个专门用于加载静态资源的宏，如：</p>
<div class="highlight"><pre><span></span><code>{% macro static_file(type, filename_or_url, local=True) %}
            {% if local %}
                {% set filename_or_url = url_for(&#39;static&#39;, filename=filename_or_url) %}
            {% endif %}
            {% if type == &#39;css&#39; %}
                &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ filename_or_url }}&quot; type=&quot;text/css&quot;&gt;
            {% elif type == &#39;js&#39; %}
                &lt;script type=&quot;text/javascript&quot; src=&quot;{{ filename_or_url }}&quot;&gt;&lt;/script&gt;
            {% elif type == &#39;icon&#39; %}
                &lt;link rel=&quot;icon&quot; href=&quot;{{ filename_or_url }}&quot;&gt;
            {% endif %}
        {% endmacro %}
</code></pre></div>

<p>在模板中导入宏后，只需在调用时传入静态资源的类别和文件路径就会获得完整的资源加载语句。使用它加载CSS文件的示例如下：</p>
<div class="highlight"><pre><span></span><code>static_file(&#39;css&#39;, &#39;css/bootstrap.min.css&#39;)
</code></pre></div>

<p>使用它也可以从CDN加载资源，只需要将关键字参数local设为False，然后传入资源的URL即可：</p>
<div class="highlight"><pre><span></span><code>static_file(&#39;css&#39;, &#39;https://maxcdn.../css/bootstrap.min.css&#39;, local=False)
</code></pre></div>

<p>1、消息闪现</p>
<p>Flask提供了一个非常有用的flash()函数，它可以用来“闪现”需要显示给用户的消息，比如当用户登录成功后显示“欢迎回来!”。在视图函数调用flash()函数，传入消息内容即可“闪现”一条消息。当然，它并不是想象的，能够立刻在用户的浏览器弹出一条消息。实际上，使用功能flash()函数发送的消息会存储在session中，需要在模板中使用全局函数get_flashed_messages()获取消息并将其显示出来。</p>
<p>可以在任意视图函数中调用flash()函数发送消息。为了测试消息闪现，添加了一个just_flash视图，在函数中发送了一条消息，最后重定向到index视图，如：</p>
<div class="highlight"><pre><span></span><code>@app.route(&#39;/flash&#39;)
def just_flash():
    flash(&quot;welcome!&quot;)
    return redirect(url_for(&#39;watchlist&#39;))
</code></pre></div>

<p>Flask提供了get_ flashed_message()函数用来在模板里获取消息，因为程序的每一个页面都有可能需要显示消息，把获取并显示消息的代码放在基模板中content块的上面，这样就可以在页面主体内容的上面显示消息。</p>
<div class="highlight"><pre><span></span><code>&lt;main&gt;
    {% for message in get_flashed_messages() %}
        &lt;div class=&quot;alert&quot;&gt;{{ message }}&lt;/div&gt;
    {% endfor %}
    {% block content %}{% endblock %}
&lt;/main&gt;
</code></pre></div>

<p>当get_flashed_message()函数被调用时，session中存储的所有消息都会被移除。如果这时刷新页面，会发现重载后的页面不再出现这条消息。</p>
<p>Jinja2内部使用Unicode，所以需要向模板传递Unicode对象或只包含ASCII字符的字符串。在Python 2.x中，如果字符串包含中文（或任何非ASCII字符），那么需要在字符串前添加u前缀（如：u'大家好，这是测试消息），这会告诉Python把这个字符串编码成Unicode字符串，另外还需要在Python文件的首行添加编码声明，这会让Python使用UTF-8来解码字符串，后面不再提示。</p>
<p>Flask、Jinja2和Werkzeug等相关依赖均将文本的类型设为Unicode，所以在编写程序和它们交互时应该遵循同样的约定。比如，在Python脚本中添加编码声明;在Python2中为非ASCII字符添加u前缀;将编辑器的默认编码设为UTF-8;在HTML文件的head标签中添加编码声明，即\&lt;meta charset="utf-8">;当需要读取文件传入模板时，手动使用decode()函数解码。</p>
<p>2、自定义错误页面</p>
<p>当程序返回错误响应时，会渲染一个默认的错误页面，默认的错误页面太简单了，而且和其他页面的风格不符，导致用户看到这样的页面时往往会不知所措。可以注册错误处理函数来自定义错误页面。
错误处理函数和视图函数很相似，返回值将会作为响应的主体，因此首先要创建错误页面的模板文件。为了和普通模板区分开来，在模板文件夹templates里为错误页面创建了一个errors子文件夹，并在其中为最常见的404和500错误创建了模板文件。</p>
<div class="highlight"><pre><span></span><code>{% extends &#39;base.html&#39; %}
{% block title %}404 - Page Not Found{% endblock %}
{% block content %}
&lt;h1&gt;Page Not Found&lt;/h1&gt;
&lt;p&gt;You are lost...&lt;/p&gt;
{% endblock %}
</code></pre></div>

<p>错误处理函数需要附加app.errorhandler()装饰器，并传入错误状态码作为参数。错误处理函数本身则需要接收异常类作为参数，并在返回值中注明对应的HTTP状态码。当发生错误时，对应的错误处理函数会被调用，它的返回值会作为错误响应的主体。</p>
<div class="highlight"><pre><span></span><code>@app.errorhandler(500)
def internal_server_error(e):
    return render_template(&#39;errors/500.html&#39;), 500
@app.errorhandler(404)
def page_not_found(e):
    return render_template(&#39;errors/404.html&#39;), 404
</code></pre></div>

<p><img alt="image-20210208144333361" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210208144333361.png" /></p>
<p>错误处理函数接收异常对象作为参数，内置的异常对象提供了下列常用属性：</p>
<p><img alt="image-20210208144544159" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210208144544159.png" /></p>
<h3 id="java-scriptcssjinja2">Java Script和CSS中的Jinja2<a class="headerlink" href="#java-scriptcssjinja2" title="Permanent link">&para;</a></h3>
<p>当程序逐渐变大时，很多时候会需要在Java Script和CSS代码中使用Jinja2提供的变量值，甚至是控制语句。比如，通过传入模板的theme_color变量来为页面设置主题色彩，或是根据用户是否登录来决定是否执行某个Java Script函数。
首先要明白的是，只有使用render_template()传入的模板文件才会被渲染，如果把Jinja2代码写在单独的Java Script或是CSS文件中，尽管在HTML中引入了它们，但它们包含的Jinja2代码永远也不会被执行。</p>
<p>1、行内/嵌入式Java Script/CSS</p>
<p>如果要在Java Script和CSS文件中使用Jinja2代码，那么就在HTML中使用\&lt;style>和\&lt;script>标签定义这部分CSS和Java Script代码。
在这部分CSS和Java Script代码中加入Jinja2时，不用考虑编写时的语法错误，比如引号错误，因为Jinja2会在渲染后被替换掉，所以只需要确保渲染后的代码正确即可。
不过并不推荐使用这种方式，尤其是行内Java Script/CSS会让维护变得困难。避免把大量Java Script代码留在HTML中的办法就是尽量将要使用的Jinja2变量值在HTML模板中定义为Java Script变量。</p>
<p>2、定义为Java Script/CSS变量</p>
<p>对于想要在Java Script中获取的数据，如果是元素特定的数据，比如某个文章条目对应的id值，可以通过HTML元素的data-*属性存储。可以自定义横线后的名称，作为元素上的自定义数据变量，比如data-id, data-username等，比如：</p>
<div class="highlight"><pre><span></span><code>&lt;span  data-id=&quot;{{  user.id  }}&quot;  data-username=&quot;{{  user.username  }}&quot;&gt;{{  user.username }}&lt;/span&gt;
</code></pre></div>

<p>在Java Script中，可以使用DOM元素的dataset属性获取data-*属性值，比如element. dataset.username，或是使用get Attribute()方法，比如element.getAttribute('data-username');使用j Query时，可以直接对j Query对象调用data方法获取，比如$element.data('username')。</p>
<p>在HTML中,“data-*”被称为自定义数据属性(custom data attribute)，可以用它来存储自定义的数据供Java Script获取。
对于需要全局使用的数据，则可以在页面中使用嵌入式Java Script定义变量，如果没法定义为Java Script变量，那就考虑定义为函数。</p>
<div class="highlight"><pre><span></span><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var foo = &#39;{{ foo_variable }}&#39;;
&lt;/script&gt;
</code></pre></div>

<p>CSS同理，有些时候会需要将Jinja2变量值传入CSS文件，比如希望将用户设置的主题颜色设置到对应的CSS规则中，或是需要将static目录下某个图片的URL传入CSS来设置为背景图片，除了将这部分CSS定义直接写到HTML中外，可以将这些值定义为CSS变量。</p>
<div class="highlight"><pre><span></span><code>&lt;style&gt;
:root {
    --theme-color: {{ theme_color }};
    --background-url: {{ url_for(&#39;static&#39;, filename=&#39;background.jpg&#39;) }}
}
&lt;/style&gt;
</code></pre></div>

<p>在CSS文件中，使用var()函数并传入变量名即可获取对应的变量值：</p>
<div class="highlight"><pre><span></span><code>#foo {
    color: var(--theme-color);
}
#bar {
    background: var(--background-url);
}
</code></pre></div>

<h2 id="_30">表单<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h2>
<p>在Web程序中，表单是和用户交互最常见的方式之一。用户注册、登录、撰写文章、编辑设置，无一不用到表单。不过，表单的处理却并不简单。不仅要创建表单，验证用户输入的内容，向用户显示错误提示，还要获取并保存数据。幸运的是，强大的WTForms可以帮解决这些问题。WTForms是一个使用Python编写的表单库，它使得表单的定义、验证（服务器端）和处理变得非常轻松。</p>
<h3 id="html_3">html表单<a class="headerlink" href="#html_3" title="Permanent link">&para;</a></h3>
<p>在HTML中，表单通过\&lt;form>标签创建，表单中的字段使用\&lt;input>标签定义。</p>
<div class="highlight"><pre><span></span><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;This is a test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method=&quot;post&quot;&gt;
&lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;&lt;br&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Your username&quot;&gt;&lt;br&gt;
    &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;&lt;br&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Your password&quot;&gt;&lt;br&gt;
    &lt;input id=&quot;remember&quot; name=&quot;remember&quot; type=&quot;checkbox&quot; checked&gt;
    &lt;label for=&quot;remember&quot;&gt;&lt;small&gt;Remember me&lt;/small&gt;&lt;/label&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>

<div class="highlight"><pre><span></span><code>@app.route(&quot;/test&quot;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test():
    return render_template(&quot;test.html&quot;)
</code></pre></div>

<p>运行效果：</p>
<p><img alt="image-20210220102702302" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210220102702302.png" /></p>
<p>WTForms支持在Python中使用大考的更易于重用。因此，除非是非常简单HTML代码，这种方式更加方便，而且使表单更易于重用。因此，除非是非常简单的程序，或者是想让表单的定义更加灵活，否则一般不会在模板中直接使用HTML编写表单。</p>
<h3 id="flask-wtf">使用Flask-WTF处理表单<a class="headerlink" href="#flask-wtf" title="Permanent link">&para;</a></h3>
<p>扩展Flask-WTF集成了WTForms，使用它可以在Flask中更方便地使用WTForms。Flask-WTF将表单数据解析、CSRF保护、文件上传等功能与Flask集成，另外还附加了re CAPTCHA支持。</p>
<p>Flask-WTF默认为每个表单启用CSRF保护，它会为自动生成和验证CSRF令牌。默认情况下，Flask-WTF使用程序密钥来对CSRF令牌进行签名，所以需要为程序设置密钥:</p>
<div class="highlight"><pre><span></span><code> app.secret_key = &#39;secret string&#39;
</code></pre></div>

<h3 id="wtforms">定义WTForms表单类<a class="headerlink" href="#wtforms" title="Permanent link">&para;</a></h3>
<p>当使用WTForms创建表单时，表单由Python类表示，这个类继承从WTForms导入的Form基类。一个表单由若干个输入字段组成，这些字段分别用表单类的类属性来表示(字段即Field，可以简单理解为表单内的输入框、按钮等部件)。下面定义了一个Login Form类，最终会生成在前面定义的HTML表单:</p>
<div class="highlight"><pre><span></span><code>from wtforms import Form, StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length
class LoginForm(Form):
    username = StringField(&#39;Username&#39;, validators=[DataRequired()])
    password = PasswordField(&#39;Password&#39;, validators=[DataRequired(), Length(8, 128)])
    remember = BooleanField(&#39;Remember me&#39;)
    submit = SubmitField(&#39;Log in&#39;)
</code></pre></div>

<p><em>每个字段属性通过实例化WTForms提供的字段类表示。字段属性的名称将作为对应HTML\&lt;input>元素的name属性及id属性值。</em></p>
<p><em>字段属性名称大小写敏感，不能以下划线或validate开头。</em>
这里的Login Form表单类中定义了四个字段:文本字段String Field、密码字段Password-Field、勾选框字段Boolean Field和提交按钮字段Submit Field。字段类从wtforms包导入，常用的WTForms字段如:</p>
<p><img alt="image-20210220112429284" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210220112429284.png" /></p>
<p><em>有些字段最终生成的HTML代码相同，不过WTForms会在表单提交后根据表单类中字段的类型对数据进行处理，转换成对应的Python类型，以便在Python脚本中对数据进行处理。</em>
通过实例化字段类时传入的参数，可以对字段进行设置，字段类构造方法接收的常用参数如:</p>
<p><img alt="image-20210220112542018" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210220112542018.png" /></p>
<p>在WTForms中，验证器(validator）是一系列用于验证字段数据的类，在实例化字段类时使用validators关键字来指定附加的验证器列表。验证器从wtforms.validators模块中导入，常用的验证器如:</p>
<p><img alt="image-20210220141504545" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210220141504545.png" /></p>
<p>在实例化验证类时，message参数用来传入自定义错误消息，如果没有设置则使用内置的英文错误消息，后面了解如何使用内置的中文错误消息。</p>
<p><em>validators参数接收一个传入可调用对象组成的列表。内置的验证器通过实现了_call_()方法的类表示，所以需要在验证器后添加括号。</em></p>
<p>在name和password字段里，都使用了Data Required验证器，用来验证输入的数据是否有效。另外，password字段里还添加了一个Length验证器，用来验证输入的数据长度是否在给定的范围内。验证器的第一个参数一般为错误提示消息，可以使用message关键字传递参数，通过传入自定义错误信息来覆盖内置消息，比如:</p>
<div class="highlight"><pre><span></span><code>name = String Field(&#39;Your Name&#39;, validators=[Data Required(message=u&#39;名字不能为空！&#39;)])
</code></pre></div>

<p>当使用Flask-WTF定义表单时，仍然使用WTForms提供的字段类和验证器，创建的方式也完全相同，只不过表单类要继承Flask-WTF提供的Flask Form类。Flask Form类继承自Form类，进行了一些设置，并附加了一些辅助方法，以便与Flask集成。因为本章的示例程序中包含多个表单类，为了便于组织，创建了一个forms.py脚本，用来存储所有的表单类。</p>
<p><em>配置键WTF_CSRF_ENABLED用来设置是否开启CSRF保护，默认为True。Flask-WTF会自动在实例化表单类时添加一个包含CSRF令牌值的隐藏字段，字段名为csrf_token。</em></p>
<h3 id="html_4">输出html代码<a class="headerlink" href="#html_4" title="Permanent link">&para;</a></h3>
<p>以使用WTForms创建的Login Form为例，实例化表单类，然后将实例属性转换成字符串或直接调用就可以获取表单字段对应的HTML代码:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; form = LoginForm()
&gt;&gt;&gt; form.username()
    u&#39;&lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot; value=&quot;&quot;&gt;&#39;
&gt;&gt;&gt; form.submit()
    u&#39;&lt;input id=&quot;submit&quot; name=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&#39;
</code></pre></div>

<p>字段的\<label>元素的HTML代码则可以通过“form.字段名.label”的形式获取:</p>
<div class="highlight"><pre><span></span><code> &gt;&gt;&gt; form.username.label()
    u&#39;&lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;&#39;
&gt;&gt;&gt; form.submit.label()
    u&#39;&lt;label for=&quot;submit&quot;&gt;Submit&lt;/label&gt;&#39;
</code></pre></div>

<p>在创建HTML表单时，经常会需要使用HTML\<input>元素的其他属性来对字段进行设置。比如，添加class属性设置对应的CSS类为字段添加样式;添加placeholder属性设置占位文本。默认情况下，WTForms输出的字段HTML代码只会包含id和name属性，属性值均为表单类中对应的字段属性名称。如果要添加额外的属性，通常有两种方法。</p>
<h3 id="render_kw">使用render_kw属性<a class="headerlink" href="#render_kw" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>username = StringField(&#39;Username&#39;, render_kw={&#39;placeholder&#39;: &#39;Your Username&#39;})
</code></pre></div>

<p>这个字段被调用后输出的HTML代码如下所示:</p>
<div class="highlight"><pre><span></span><code>&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Your Username&quot;&gt;
</code></pre></div>

<h3 id="_31">在调用字段时传入<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
<p>在调用字段属性时，通过添加括号使用关键字参数的形式也可以传入字段额外的HTML属性:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; form.username(style=&#39;width: 200px; &#39;, class_=&#39;bar&#39;)
    u&#39;&lt;input class=&quot;bar&quot; id=&quot;username&quot; name=&quot;username&quot; style=&quot;width: 200px; &quot; type=&quot;text&quot;&gt;&#39;
</code></pre></div>

<p>class是 Python的保留关键字，在这里使用class_来代替class，渲染后的\&lt;input>会获得正确的class属性，在模板中调用时则可以直接使用class。
<em>通过上面的方法也可以修改id和name属性，但表单被提交后，WTForms需要通过name属性来获取对应的数据，所以不能修改name属性值。</em></p>
<h3 id="_32">在模板中渲染表单<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<p>为了能够在模板中渲染表单，需要把表单类实例传入模板。首先在视图函数里实例化表单类Login Form，然后在render_template()函数中使用关键字参数form将表单实例传入模板:</p>
<div class="highlight"><pre><span></span><code>class TestForm(FlaskForm):
    username=StringField(&#39;username&#39;,validators=[DataRequired()])
    password=PasswordField(&#39;password&#39;,validators=[DataRequired(),Length(8,128)])
    remember = BooleanField(&#39;remember?&#39;)
    submit=SubmitField(&#39;Log in&#39;)
</code></pre></div>

<div class="highlight"><pre><span></span><code>from forms import TestForm
@app.route(&quot;/test01&quot;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test01():
    form=TestForm()
    return render_template(&quot;test01.html&quot;,form=form)
</code></pre></div>

<p>在模板中，只需要调用表单类的属性即可获取字段对应的HTML代码
，如果需要传入参数，也可以添加括号：</p>
<div class="highlight"><pre><span></span><code>&lt;form method=&quot;post&quot;&gt;
    {{ form.csrf_token }} &lt;! -- 渲染CSRF令牌隐藏字段 --&gt;
    {{ form.username.label }}{{ form.username }}&lt;br&gt;
    {{ form.password.label }}{{ form.password }}&lt;br&gt;
    {{ form.remember }}{{ form.remember.label }}&lt;br&gt;
    {{ form.submit }}&lt;br&gt;
&lt;/form&gt;
</code></pre></div>

<p>需要注意的是，在上面的代码中，除了渲染各个字段的标签和字段本身，还调用了form.csrf_token属性渲染Flask-WTF为表单类自动创建的CSRF令牌字段。form.csrf_token字段包含了自动生成的CSRF令牌值，在提交表单后会自动被验证，为了确保表单通过验证，必须在表单中手动渲染这个字段。</p>
<p><img alt="image-20210222115805022" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210222115805022.png" /></p>
<p>Flask-WTF为表单类实例提供了一个form.hidden_tag()方法，这个方法会依次渲染表单中所有的隐藏字段。因为csrf_token字段也是隐藏字段，所以当这个方法被调用时也会渲染csrf_token字段。</p>
<p>使用render_kw字典或是在调用字段时传入参数来定义字段的额外HTML属性，通过这种方式添加CSS类，可以编写一个Bootstrap风格的表单:</p>
<div class="highlight"><pre><span></span><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;


{% block styles %}
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for(&#39;static&#39;,filename=&#39;css/bootstrap.min.css&#39;) }}&quot;&gt;
{% endblock %}

{% block slot %}
&lt;div class=&quot;container&quot;&gt;
    &lt;br&gt;
    &lt;a href=&quot;{{ url_for(&quot;index&quot;) }}&quot;&gt;Return&lt;/a&gt;
    &lt;br&gt;
    &lt;h1 class=&quot;display-4&quot;&gt;This Is Test01&lt;/h1&gt;
    &lt;hr&gt;
    &lt;form method=&quot;post&quot;&gt;
    {{ form.csrf_token }} &lt;! -- 渲染CSRF令牌隐藏字段 --&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            {{ form.username.label }}&lt;br&gt;{{ form.username(class=&#39;form-control&#39;) }}&lt;br&gt;
            &lt;div class=&quot;form-group&quot;&gt;
                {{ form.password.label }}&lt;br&gt;{{ form.password(class=&#39;form-control&#39;) }}&lt;br&gt;
            &lt;/div&gt;
            &lt;div class=&quot;form-check&quot;&gt;
                {{ form.remember(class=&#39;form-check-input&#39;) }}{{ form.remember.label }}&lt;br&gt;
            &lt;/div&gt;
            {{ form.submit(class=&#39;btn btn-primary&#39;) }}&lt;br&gt;
        &lt;/div&gt;
{% endblock %}
&lt;/form&gt;
&lt;/div&gt;
</code></pre></div>

<p><img alt="image-20210223102509723" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210223102509723.png" /></p>
<p>如果想手动编写HTML表单的代码，要注意表单字段的name属性值必须和表单类的字段名称相同，这样在提交表单时WTForms才能正确地获取数据并进行验证。</p>
<h3 id="_33">处理表单数据<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h3>
<p>表单数据的处理涉及很多内容，除去表单提交不说，从获取数据到保存数据大致会经历以下步骤:
1)解析请求，获取表单数据。
2)对数据进行必要的转换，比如将勾选框的值转换成Python的布尔值。
3)验证数据是否符合要求，同时验证CSRF令牌。
4)如果验证未通过则需要生成错误消息，并在模板中显示错误消息。
5)如果通过验证，就把数据保存到数据库或做进一步处理。
除非是简单的程序，否则手动处理不太现实，使用Flask-WTF和WTForms可以极大地简化这些步骤。</p>
<h3 id="_34">提交表单<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h3>
<p>在HTML中，当\&lt;form>标签声明的表单中类型为submit的提交字段被单击时，就会创建一个提交表单的HTTP请求，请求中包含表单各个字段的数据。表单的提交行为主要由三个属性控制：</p>
<p><img alt="image-20210223103635348" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210223103635348.png" /></p>
<p>form标签的action属性用来指定表单被提交的目标URL，默认为当前URL，也就是渲染该模板的路由所在的URL。如果要把表单数据发送到其他URL，可以自定义这个属性值。
当使用GET方法提交表单数据时，表单的数据会以查询字符串的形式附加在请求的URL里，比如:</p>
<div class="highlight"><pre><span></span><code>http://localhost:5000/basic?username=cyh&amp;password=12345
</code></pre></div>

<p>GET方式仅适用于长度不超过3000个字符，且不包含敏感信息的表单。因为这种方式会直接将用户提交的表单数据暴露在URL中，容易被攻击者截获，示例中的情况明显是危险的。因此，出于安全的考虑，一般使用POST方法提交表单。使用POST方法时，按照默认的编码类型，表单数据会被存储在请求主体中，比如:</p>
<div class="highlight"><pre><span></span><code>POST /basic HTTP/1.0
...
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=cyh&amp;password=12345
</code></pre></div>

<p>Flask为路由设置默认监听的HTTP方法为GET。为了支持接收表单提交发送的POST请求，必须在app.route()装饰器里使用methods关键字为路由指定HTTP方法:</p>
<div class="highlight"><pre><span></span><code>@app.route(&quot;/test01&quot;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test01():
    form=TestForm()
    return render_template(&quot;test01.html&quot;,form=form)
</code></pre></div>

<h3 id="_35">验证表单数据<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h3>
<h4 id="_36">客户端验证和服务端验证<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h4>
<p>1、客户端验证</p>
<p>客户端验证(client side validation）是指在客户端（比如Web浏览器）对用户的
输入值进行验证。比如，使用HTML5内置的验证属性即可实现基本的客尸端验让(type、required、min、max、accept等)。比如，下面的username字段添加了required标志:</p>
<div class="highlight"><pre><span></span><code>username=StringField(&#39;用户名&#39;,validators=[DataRequired()])
</code></pre></div>

<div class="highlight"><pre><span></span><code>&lt;input class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot; required=&quot;&quot; type=&quot;text&quot; value=&quot;&quot;&gt;
</code></pre></div>

<p>和其他附加HTML属性相同，可以在定义表单时通过render_kw传入这些属性，或是在渲染表单时传入。像required这类布尔值属性，值可以为空或是任意ASCII字符，比如:</p>
<div class="highlight"><pre><span></span><code>{{ form.username(required=&#39;&#39;) }}
</code></pre></div>

<p>除了使用HTML5提供的属性实现基本的客户端验证，通常会使用Java Script实现完善的验证机制。如果不想手动编写Java Script代码实现客户端验证，可以考虑使用各种Java Script表单验证库，比如j Query Validation Plugin(<a href="https://jqueryvalidation.org/">https://jqueryvalidation.org/</a>) . Parsley. js ( <a href="http://parsleyjs.org/)以及可与Bootstrap集成的Bootstrap">http://parsleyjs.org/)以及可与Bootstrap集成的Bootstrap</a> Validator ( <a href="http://1000hz.github.io/bootstrap-validator/">http://1000hz.github.io/bootstrap-validator/</a>，目前仅支持Bootstrap3版本)等。</p>
<p>客户端方式可以实时动态提示用户输入是否正确，只有用户输入正确后才会将表单数据发送到服务器。客户端验证可以增强用户体验，降低服务器负载。</p>
<p>2、服务端验证</p>
<p>服务器端验证(server side validation）是指用户把输入的数据提交到服务器端，在服务器端对数据进行验证。如果验证出错，就在返回的响应中加入错误信息。用户修改后再次提交表单，直到通过验证。在Flask程序中使用WTForms实现的就是服务器端验证。
在这里不必纠结使用何种形式，因为无论是否使用客户端验证，服务器端验证都是必不可少的，因为用户可以通过各种方式绕过客户端验证，比如在客户端设置禁用Java Script。对于玩具程序来说，可以不用考虑那么多，但对于真实项目来说，绝对不能忽视任何安全问题。</p>
<h3 id="wtforms_1">WTForms验证机制<a class="headerlink" href="#wtforms_1" title="Permanent link">&para;</a></h3>
<p>WTForms验证表单字段的方式是在实例化表单类时传入表单数据，然后对表单实例调用validate()方法。这会逐个对字段调用字段实例化时定义的验证器，返回表示验证结果的布尔值。如果验证失败，就把错误消息存储到表单实例的errors属性对应的字典中。</p>
<p>因为表单使用POST方法提交，如果单纯使用WTForms，在实例化表单类时需要首先把request.form传入表单类，而使用Flask-WTF时，表单类继承的Flask Form基类默认会从request.form获取表单数据，所以不需要手动传入。</p>
<p>使用POST方法提交的表单，其数据会被Flask解析为一个字典，可以通过请求对象的form属性获取(request.form);使用GET方法提交的表单的数据同样会被解析为字典，不过要通过请求对象的args属性获取(request.args)。</p>
<h3 id="_37">在视图函数中验证表单<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>因为现在的basic_form视图同时接收两种类型的请求:GET请求和POST请求。所以要根据请求方法的不同执行不同的代码。具体来说:首先是实例化表单，如果是GET请求，那么就渲染模板;如果是POST请求，就调用validate()方法验证表单数据。
请求的HTTP方法可以通过request.method属性获取，可以使用下面的方式来组织视图函数:</p>
<div class="highlight"><pre><span></span><code>@app.route(&quot;/test01&quot;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test01():
    form=TestForm()
    if request.method==&#39;POST&#39; and form.validate():
        username=request.form.get(&#39;username&#39;)
        flash(&#39;welcome home,%s!&#39;%username)
        return redirect(url_for(&#39;index&#39;))
    return render_template(&quot;test01.html&quot;,form=form)
</code></pre></div>

<p>当请求方法是GET时，会跳过这个if语句，渲染basic.html模板;当请求的方法是POST时(说明用户提交了表单），则验证表单数据。这会逐个字段(包括CSRF令牌字段)调用附加的验证器进行验证。</p>
<p>因为WTForms会自动对CSRF令牌字段进行验证，如果没有渲染该字段会导致验证出错，错误消息为“CSRF token is missing"。Flask-WTF提供的validate_on_submit()方法合并了这两个操作，因此代码可以简化为:</p>
<div class="highlight"><pre><span></span><code>if form.validate_on_submit():
</code></pre></div>

<p>除了POST方法，如果请求的方法是PUT、PATCH和 DELETE方法，form.validate_on_submit()也会验证表单数据。如果form.validate_on_submit()返回True，则表示用户提交了表单，且表单通过验证，那么就可以在这个if语句内获取表单数据:</p>
<div class="highlight"><pre><span></span><code>@app.route(&quot;/test01&quot;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test01():
    form=TestForm()
    if form.validate_on_submit():
        username=form.username.data
        flash(&#39;welcome home,%s!&#39;%username)
        return redirect(url_for(&#39;index&#39;))
    return render_template(&quot;test01.html&quot;,form=form)
</code></pre></div>

<p>表单类的data属性是一个匹配所有字段与对应数据的字典，一般直接通过"form.字段属性名.data”的形式来获取对应字段的数据。例如，form.username.data返回username字段的值。如上，当表单验证成功后，获取了username字段的数据，然后用来发送一条flash消息，最后将程序重定向到index视图。</p>
<p>在这个if语句内，如果不使用重定向的话，当if语句执行完毕后会继续执行最后的render_template()函数渲染模板，最后像往常一样返回一个常规的200响应，但这会造成一个问题:
在浏览器中，当单击F5刷新/重载时的默认行为是发送上一个请求。如果上一个请求是POST请求，那么就会弹出一个确认窗口，询问用户是否再次提交表单。<em>为了避免出现这个容易让人产生困惑的提示，尽量不要让提交表单的POST请求作为最后一个请求。这就是为什么在处理表单后返回一个重定向响应，这会让浏览器重新发送一个新的GET请求到重定向的目标URL。最终，最后一个请求就变成了GET请求。这种用来防止重复提交表单的技术称为PRG ( Post/Redirect/Get)模式，即通过对提交表单的POST请求返回重定向响应将最后一个请求转换为GET请求。</em></p>
<h3 id="_38">在模板中渲染错误消息<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<p>如果form.validate_on_submit()返回False，那么说明验证没有通过。对于验证未通过的字段，WTForms会把错误消息添加到表单类的errors属性中，这是一个匹配作为表单字段的类属性到对应的错误消息列表的字典。一般会直接通过字段名来获取对应字段的错误消息列表，即“form.字段名.errors”。比如，form.name.errors返回name字段的错误消息列表。
像渲染flash()消息一样，可以在模板里使用for循环迭代错误消息列表：</p>
<div class="highlight"><pre><span></span><code>{% for message in form.password.errors %}
&lt;small class=&quot;error&quot;&gt;{{ message }}&lt;/small&gt;
{% endfor %}
</code></pre></div>

<p>在使用Data Required和Input Required验证器时，WTForms会在字段输出的HTML代码中添加required属性，所以会弹出浏览器内置的错误提示。同时，WTForms也会在表单字段的flags属性添加required标志(比如form.username.flags.required)，所以可以在模板中通过这个标志值来判断是否在字段文本中添加一个*号或文字标注，以表示必填项。
如果在用户名字段输入空格，在密码字段输入的数值长度小于6，返回响应后会看到对应的错误消息显示在字段下方：</p>
<p><img alt="image-20210223154009980" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210223154009980.png" /></p>
<p>lnput Required验证器和Data Required很相似，但Input Required仅验证用户是否有输入，而不管输入的值是否有效。例如，由空格组成的数据也会通过验证。当使用Data Required时，如果用户输入的数据不符合字段要求，比如在IntegerField输入非数字时会视为未输入，而不是类型错误。
至此，已经介绍了在Python中处理HTML表单的所有基本内容。完整的表单处理过程的流程图如：</p>
<p><img alt="img" src="flask入门.assets/epub_22987517_236" /></p>
<h2 id="_39">表单实践<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h2>
<h3 id="_40">设置错误消息语言<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<p>WTForms内置了多种语言的错误消息，如果想改变内置错误消息的默认语言，可以通过自定义表单基类实现(Flask-WTF版本&gt;0.14.2)。
实现这个功能需要确保Flask-WTF版本&gt;0.14.2或单独使用WTForms。
示例程序创建了一个My Base Form基类，所有继承这个基类的表单类的内置错误消息语言都会设为简体中文。</p>
<div class="highlight"><pre><span></span><code>from flask_wtf import FlaskForm
from wtforms import StringField,SubmitField
from wtforms.validators import DataRequired

class TestForm02(FlaskForm):
    class Meta:
        locals=[&#39;zh&#39;]
class TestForm03(TestForm02):
    name=StringField(&#39;name&#39;,validators=[DataRequired()])
    submit=SubmitField()

app = Flask(__name__)
app.config[&#39;WTF_I18N_ENABLED&#39;] = False
app.config[&quot;SECRET_KEY&quot;] = &quot;12345678&quot;

@app.route(&#39;/test03&#39;,methods=[&#39;GET&#39;,&#39;POST&#39;])
def test03():
    form=TestForm03()
    if form.validate_on_submit():
        name=form.name
        flash(&#39;hello %s&#39;%name)
        return redirect(url_for(&#39;index&#39;))
    return render_template(&#39;TestForm03.html&#39;,form=form)
</code></pre></div>

<div class="highlight"><pre><span></span><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;This is a test!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form method=&quot;post&quot;&gt;
{{ form.csrf_token }}
    &lt;div&gt;
        &lt;h1&gt;This is a test!&lt;/h1&gt;&lt;br&gt;
    &lt;/div&gt;
{{ form.name }}
{{ form.submit }}
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>

<p>首先，需要将配置变量WTF_I18N_ENABLED设为False，这会让Flask-WTF使用WTForms内置的错误消息翻译。然后需要在自定义基类中定义Meta类，并在locales列表中加入简体中文的地区字符串。在创建表单时，继承这个My BaseForm即可将错误消息语言设为中文，比如上面定义的TestForm03。另外，也可以在实例化表单类时通过meta关键字传入locales值，比如:</p>
<div class="highlight"><pre><span></span><code>form = MyForm(meta={&#39;locales&#39;: [&#39;en_US&#39;, &#39;en&#39;]})
</code></pre></div>

<p>locales属性是一个根据优先级排列的地区字符串列表。在WTForms中，简体中文和繁体中文的地区字符串分别为zh和zh_TW。</p>
<h3 id="_41">使用宏渲染表单<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h3>
<p>在模板中渲染表单时，有大量的工作要做:
1、调用字段属性，获取\&lt;input>定义。
2、调用对应的label属性，获取\&lt;label>定义。
3、渲染错误消息。</p>
<p>为了避免为每一个字段重复这些代码，可以创建一个宏来渲染表单字段：</p>
<div class="highlight"><pre><span></span><code>{% macro form_field(field) %}
    {{ field.label }}&lt;br&gt;
    {{ field(＊＊kwargs) }}&lt;br&gt;
    {% if field.errors %}
        {% for error in field.errors %}
            &lt;small class=&quot;error&quot;&gt;{{ error }}&lt;/small&gt;&lt;br&gt;
        {% endfor %}
    {% endif %}
{% endmacro %}
</code></pre></div>

<p>这个form_field()宏接收表单类实例的字段属性和附加的关键字参数作为输入，返回包含\&lt;label>标签、表单字段、错误消息列表的HTML表单字段代码。使用这个宏渲染表单的示例如下所示:</p>
<div class="highlight"><pre><span></span><code>{% from &#39;macros.html&#39; import form_field %}
.
&lt;form method=&quot;post&quot;&gt;
    {{ form.csrf_token }}
    {{ form_field(form.username)}}&lt;br&gt;
    {{ form_field(form.password) }}&lt;br&gt;
    .
&lt;/form&gt;
</code></pre></div>

<p>在上面的代码中，调用form_field()宏逐个渲染表单中的字段，只要把每一个类属性传入form_field()宏，即可完成渲染。</p>
<h3 id="_42">自定义验证器<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h3>
<p>在WTForms中，验证器是指在定义字段时传入validators参数列表的可调用对象。</p>
<p>1、行内验证器</p>
<p>除了使用WTForms提供的验证器来验证表单字段，还可以在表单类中定义方法来验证特定字段：</p>
<div class="highlight"><pre><span></span><code>class MustBe07(FlaskForm):
    answer=IntegerField(&#39;The number&#39;)
    submit=SubmitField(&#39;Enter&#39;)
    def validate_answer(form,field):
        if field.data!=7:
            raise ValidationError(&quot;Must be 7&quot;)
</code></pre></div>

<p>当表单类中包含以“validate_字段属性名”形式命名的方法时，在验证字段数据时会同时调用这个方法来验证对应的字段，这也是为什么表单类的字段属性名不能以validate开头。验证方法接收两个位置参数，依次为form和field，前者为表单类实例，后者是字段对象，可以通过field.data获取字段数据，这两个参数将在验证表单时被调用传入。验证出错时抛出从wtforms.validators模块导入的Validation Error异常，传入错误消息作为参数。因为这种方法仅用来验证特定的表单类字段，所以又称为行内验证器(in-line validator)。</p>
<div class="highlight"><pre><span></span><code>from forms import MustBe07
@app.route(&quot;/must&quot;,methods=[&#39;GET&#39;,&quot;POST&quot;])
def mustbe07():
    form=MustBe07()
    if form.validate_on_submit():
        return redirect(url_for(&#39;index&#39;))
    return render_template(&quot;mustbe07.html&quot;,form=form)
</code></pre></div>

<div class="highlight"><pre><span></span><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
{% from &#39;macros.html&#39; import form_field %}
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{{ url_for(&#39;static&#39;, filename=&#39;style.css&#39; ) }}&quot;&gt;
    &lt;title&gt;MustBe07&lt;/title&gt;
    &lt;h1&gt;MustBe07&lt;/h1&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;form method=&quot;post&quot;&gt;
        {{ form.answer.label }}&lt;br&gt;
        {{ form.answer}}&lt;br&gt;
        {% if form.answer.errors %}
            {% for message in form.answer.errors %}
                &lt;small class=&quot;error&quot;&gt;{{ message }}&lt;/small&gt;&lt;br&gt;
            {% endfor %}
        {% endif %}
        &lt;br&gt;{{ form.submit}}
    &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>

<p>运行效果：</p>
<p><img alt="image-20210225113452577" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210225113452577.png" /></p>
<h3 id="_43">全局验证器<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h3>
<p>如果想要创建一个可重用的通用验证器，可以通过定义一个函数实现。如果不需要传入参数定义验证器，那么一个和表单类中定义的验证方法完全相同的函数就足够了。</p>
<div class="highlight"><pre><span></span><code>def is_10(form,field):
    if field.data!=10:
        raise ValidationError(&quot;is not 10!&quot;)
class MustBe07(FlaskForm):
    answer=IntegerField(&#39;The number&#39;,validators=[is_10])
    submit=SubmitField(&#39;Enter&#39;)
    def validate_answer(form,field):
        if field.data!=7:
            raise ValidationError(&quot;Must be 7&quot;)
</code></pre></div>

<p>运行效果：</p>
<p><img alt="image-20210225114050474" src="../flask%E5%85%A5%E9%97%A8.assets/image-20210225114050474.png" /></p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../../git/%E5%90%8C%E6%AD%A5mkdocs%E5%88%B0%E5%A4%9A%E4%B8%AAgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" title="同步mkdocs到多个git远程仓库" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                同步mkdocs到多个git远程仓库
              </div>
            </div>
          </a>
        
        
          <a href="../../%E7%B3%BB%E7%BB%9F/windows2016%E7%94%B5%E8%AF%9D%E6%BF%80%E6%B4%BB/" title="WindowsServer电话激活操作步骤" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                WindowsServer电话激活操作步骤
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright © 2021 chyuhung
          </div>
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.3636a4ec.min.js"></script>
      <script src="../../assets/javascripts/bundle.e9fe3281.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.5eca75d3.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>